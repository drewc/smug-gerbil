#+TITLE: Gerbil Interface syntax

In Common Lisp, I really liked to use Fare's [[https://github.com/fare/lisp-interface-library][Lisp Interface Library]]. While I
love dynamic types, one of the nice things about declaring types is the following
functions now relate to them.

Gerbil Interface is a simple way to do so.

* Introduction

Interface libraries are a creative way of bringing functional programming to
gerbil. An interface class can by thought of as a type in the [[https://en.wikipedia.org/wiki/Hindley%25E2%2580%2593Milner_type_system][Hindley-Milner]]
sense, with an instance allowing overloading of the same symbols.

So, imagine there's a type called ~Monad~ that has two functions: ~result~ (aka
~return~ aka ~unit~) and a ~bind~ (aka ~>>=~). Let's define an interface class.

#+begin_src gerbil
  (define-interface-class Monad 
    (result
     (return alias: result)
     (unit alias: result)
     bind
     (>>= alias: bind)))
  ;; => Monad::interface
#+end_src

Now that we have an interface defined, we can see what it does. The list monad
has a result which creates a list, and a bind which runs a function for every
item in the list which itself returns a list, which is appended.

In other words: 

#+begin_src gerbil
  (with-interface (Monad result: list bind: (lambda (v f) (append-map f v)))
    (bind (list 1 2 3) (lambda (v) (result (+ 1 v)))))
  ;; => (2 3 4)
#+end_src

** Overloading 

Basically, the entire point of interfaces is [[https://en.wikipedia.org/wiki/Ad_hoc_polymorphism][Ad hoc polymorphism]]. We want the
same symbols to mean different things depending on what instance of an interface
type (aka class) they were passed. 

For instance, The laws which all things must obey in order to be called a monad
are simple. Where MF is a monadic function and MV a monadic value: 

#+begin_src gerbil
  (def (test-monad-laws monad x MV MF MF2)
    (with-interface (Monad monad)
     (or (equal? (bind (result x) MF) (MF x))
         (error "Left identity"))
     (or (equal? (bind MV result) MV)
         (error  "Right identity"))
     (or (equal? (bind (bind MV MF) MF2) (bind MV (lambda (x) (bind (MF x) MF2))))
         (error  "Associativity" ))))
#+end_src

So, we'll create two instances that for sure pass the tests.

#+begin_src gerbil
  (import :std/srfi/1
          (for-syntax :std/srfi/1))
  (def ListMonad (make-interface 'Monad result: list bind: (lambda (v f) (append-map f v))))
  (def IdentityMonad (make-interface 'Monad result: identity bind: (lambda (v f) (f v))))
#+end_src

Now we can use the same function on different monads.


#+begin_src gerbil
  (test-monad-laws IdentityMonad 1 2 (cut + 3 <>) (cut + 4 <>))
  (test-monad-laws ListMonad 1 (list 2) (lambda (v) (list (+ 3 v))) (lambda (v) (list (+ 4 v))))
#+end_src

** Default values

Often, we want symbols to have a default value for every instance of an
interface made from that class.

#+begin_src gerbil
  (define-interface-class (ListMonad Monad) 
    ((result list)
     (bind (lambda (v f) (append-map f v)))))

  (def ListMonad (make-interface 'ListMonad))
#+end_src

Does it pass the test?

#+begin_src gerbil
  (test-monad-laws ListMonad 1 (list 2) (lambda (v) (list (+ 3 v))) (lambda (v) (list (+ 4 v))))
  ;; => #t
#+end_src

** Inline Values

Not every symbol is just a slot reference. What if they rely on other things in
the interface? What about themselves recursively?


* The Symbol Bindings :: ~with-interface~

An interface has symbols, and ~with-interface~ binds those symbols. How those
symbols are described determines how they are bound.

#+begin_src gerbil 
  (import :std/srfi/19)
  (define-interface-class Test
    ((slot 'value) ;; interface-slot
     (slot-function (cut list <...>)) ;; interface-slot
     (inline inline: (slot-function slot (date->string (current-date)))) ;; interface-inline
     ((inline-function a b) (cons slot inline)) ;; interface-inline
     (alias alias: inline-function)))  ;; interface-alias
#+end_src

** ~{interface-symbol-form interface-symbol interface-binding}

Symbols need forms! Slot access needs to know the runtime binding name of the
interface itself.

#+NAME: interface-symbol-form
 #+begin_src gerbil 
  (defmethod {interface-symbol-form interface-symbol}
    (lambda (self interface-binding-name) #!void))

  (defmethod {interface-symbol-form interface-slot}
    (lambda (self name)
      `(unchecked-slot-ref ,name ',(interface-symbol-name self))))

  (defmethod {interface-symbol-form interface-inline}
    (lambda (self _)
      (interface-inline-form self)))

  (defmethod {interface-symbol-form interface-alias}
    (lambda (self _)
       (interface-alias-to-name self)))
 #+end_src

** ~with-interface~: Now we look like a static type language! yay!

#+NAME: with-interface
#+begin_src gerbil
  (defsyntax (with-interface stx)
    (def (interface-symbol->letrec*-binding interface-symbol interface-instance interface-binding)
      [(interface-symbol-name interface-symbol)
       {interface-symbol-form interface-symbol interface-binding}])
    
    (syntax-case stx (:)
      ((macro (class: form interface: interface) body ...)
       (let* ((interface-binding (gensym))
              (interface-instance (eval `(: ,(syntax->datum #'form))))
              (bindings (map (cut interface-symbol->letrec*-binding
                               <> interface-instance interface-binding)
                          {interface-symbols interface-instance})))

         (with-syntax ((rec-bindings (datum->syntax #'macro bindings))
                       (interface-let-name (datum->syntax #'macro interface-binding)))
           #'(let (interface-let-name interface) (letrec* rec-bindings body ...)))))
  ;;; If we are using the (: class ...) macro, use (class (: class ...)) as
  ;;; the interface
      ((macro (: name args ...) body ...)
       #'(macro (class: name interface: (: name args ...)) body ...))
  ;;; Now (class/interface interface) 
      ((macro (expr interface) body ...)
       (let* ((intername (gensym))
              (interform (syntax->datum #'expr))
              ;; Are we given an interface instance or a class
              (instance (with-catch (lambda (_) #f) (lambda () (eval interform)))))
         (with-syntax ((class-name (type-id (object-type (or instance (eval `(: ,interform)))))))
           #'(macro (class: class-name interface: interface) body ...))))
      ((macro (interface rest ...) body ...)
       #'(macro (interface (: interface rest ...))
           body ...))
      ((macro expr body ...)
       #'(macro (expr expr) body ...))))
#+end_src

* Interface Instance 

If we're passed a symbol, use symbol::interface. the ~:~ macro does so automagically.

#+NAME: make-interface
#+begin_src gerbil
  (def (make-interface interface . args)
    (apply make-class-instance
      (cond
       ((class-type? interface) interface)
       ((symbol? interface)
             (eval (string->symbol (string-append (symbol->string interface)
                                   "::interface"))))
       (else (object-type interface)))
      args))

  (defsyntax (: interface)
    (syntax-case interface ()
      ((macro name args ...)
       (with-syntax ((name (datum->syntax #'macro (string->symbol
                                                   (string-append (symbol->string (syntax->datum #'name))
                                                                    "::interface")))))
         #'(make-interface name args ...)))))
#+end_src

* Interface Class

#+NAME: define-interface-class
#+begin_src gerbil 
    (defsyntax (define-interface-class stx)
     (def (description-form->description form)
       (match form

         ([name value] ['list ['quote name] value])
         ([[name . args] . value] ['quote name])
         ([name keyword . args] ['list ['quote name] keyword . args])
         (symbol symbol)))
     (def (singleton? args)
       (let* (name (member instance: args))
            (if name (cadr name) #f))) 

      (syntax-case stx ()
        ((macro (interface supers ...) descriptions args ...)
         (let (instance (singleton? (syntax->datum #'(args ...))))
         (with-syntax ((ds (datum->syntax #'macro (cons 'list (map description-form->description
                                            (syntax->datum  #'descriptions)))))
                       (name (datum->syntax #'macro (string->symbol
                                                     (string-append (symbol->string (syntax->datum #'interface))
                                                                    "::interface"))))
                       (super-interfaces (datum->syntax
                                             #'macro (cons 'list (map (lambda (s)
                                                                        (string->symbol
                                                                         (string-append (symbol->string s) "::interface")))
                                                                      (syntax->datum #'(supers ...))))))
                       (defi (datum->syntax #'macro (when instance
                                                      `(def ,(if (eq? instance #t)
                                                               (syntax->datum #'interface)
                                                               instance)
                                                         (make-interface ',(syntax->datum #'interface)))))))


           #'(begin (define name (make-interface-class 'interface super-interfaces ds))
                    defi
                    'name))))
        ((macro class descriptions args ...)
         #'(macro (class) descriptions args ...))))
#+end_src

** ~make-interface-class~, where it all comes together.

We've got a name, some superclasses or instances of interfaces whose classes are
supers, and some descriptions of that the symbols should be.

Time to make a class.
#+NAME: make-interface-class
#+begin_src gerbil
  (def (make-interface-class name supers descriptions)
   (def interface-symbols (map description->interface-symbol descriptions))
   (def interface-slots (filter interface-slot? interface-symbols))

   (def interface-supers (map (lambda (s)
                                (if (class-type? s) s (object-type s)))
                              supers))
   (def (create-interface-class)
     (def slots (map interface-symbol-name interface-slots))
     (make-class-type
      name (append interface-supers [Interface::t])
      slots (string->symbol (format "Interface: ~A" name))
      [] ':init!))

   (let ((klass (create-interface-class)))
     (begin0 klass
       ;; Bind the symbols
       (bind-method! klass 'interface-symbols
                     (lambda (obj) (append interface-symbols
                                      (call-next-method klass obj 'interface-symbols))))
       ;; Bind :init!
       (bind-interface-init! klass interface-symbols))))
#+end_src

** Root Class: Interface
An interface class is made up of symbols. They all start with an actual standard
gerbil class and two methods, ~:init!~ and ~interface-symbols~.

#+NAME: defclass-interface
#+begin_src gerbil 
  (defclass Interface () constructor: :init!)

  (defmethod {:init! Interface}
    (cut class-instance-init! <...>))

  (defmethod {interface-symbols Interface}
    (lambda _ []))
#+end_src

** Interface Symbols 

An interface has symbols.

#+NAME: interface-symbols-def
#+begin_src gerbil
  (defstruct interface-symbol (name))

  (defstruct (interface-slot interface-symbol)
    (value))

  (defstruct (interface-inline interface-symbol)
    (form))

  (defstruct (interface-alias interface-symbol)
    (to-name))
#+end_src

*** Descriptions of symbols

Because there are different types of symbols, and interfaces are all about
syntax, how we describe them declares what type of symbol they are.

#+begin_src gerbil

  (def test-descriptions ['symbol ['list list] ['sequence alias: 'list]])

  (map description->interface-symbol test-descriptions)
  ;; => (#<interface-slot #15> #<interface-slot #16> #<interface-alias #17>)
#+end_src

#+NAME: description->interface-symbol
#+begin_src gerbil
  (def (description->interface-symbol description)
    (cond
     ;; If the description is just a symbol, this a reference to a slot.
     ;; Use the absent-obj so we do not have a default value.
     ((symbol? description)
      (make-interface-slot description absent-obj))
     ;; If it's a list, match it!
     ((list? description)
      (match description
        ;; (name inline: value) is inline form
        ([name inline: form] (make-interface-inline name form))
        ;; ((name . args) . body) is an inline form with (lambda args body ...)
        ([[name . args] . body] (make-interface-inline name `(lambda ,args ,@body)))
        ;; (name alias: to-name) is an alias
        ([name alias: to-name] (make-interface-alias name to-name))
        ;; otherwise, slot and default value
        ([name default] (make-interface-slot name default))))
     (else (error "Invalid Interface Description syntax"))))
#+end_src

*** ~:init!~ for default values

  If we describe a symbol as being a slot with a default value, we need to set
  it at init time. However, if we are passing in an initial value with a
  keyword, we need no default.

#+name: bind-interface-init!
#+begin_src gerbil 
  (def (bind-interface-init! klass interface-symbols)
    (bind-method! 
     klass ':init! 
     (lambda (self . args)
       (def (add-args (syms interface-symbols))
         (let* ((isym (car syms))
                (sym (interface-symbol-name isym))
                (key (symbol->keyword sym)))
           (when (and (interface-slot? isym)
                    (not (eqv? absent-obj (interface-slot-value isym)))
                    (not (member key args)))
             (set! args (append [key (interface-slot-value isym)] args))) 
             (unless (null? (cdr syms)) (add-args (cdr syms)))))
       (add-args)
       (apply call-next-method klass self ':init! args))))
#+end_src


* /file/ interface.ss

#+begin_src gerbil :noweb yes :tangle interface.ss


    (module istructs-and-classes
     (export #t)
     <<interface-symbols-def>>

     <<defclass-interface>>)

  (import :gerbil/core 
   (for-syntax :std/format)
   :std/format 
   (for-syntax istructs-and-classes)
   istructs-and-classes
   :std/iter :std/sugar :std/generic 
   (for-syntax :std/misc/rtd)) 
  (export with-interface define-interface-class make-interface make-interface-class interface-slot interface-slot-value)


    <<description->interface-symbol>>

    <<bind-interface-init!>>
    <<make-interface-class>>

    <<define-interface-class>>

    <<make-interface>>

    (begin-syntax 
      <<interface-symbol-form>>)

    <<with-interface>>
#+end_src
