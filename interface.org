#+TITLE: Gerbil Interface syntax

In Common Lisp, I really liked to use Fare's [[https://github.com/fare/lisp-interface-library][Lisp Interface Library]]. While I
love dynamic types, one of the nice things about declaring types is the following
functions now relate to them.

Gerbil Interface is a simple way to do so.

* Introduction

Interface libraries are a create way of bringing functional programming to
gerbil. In particular, Monads are different things with the same functional
interface. Gerbil interfaces are a wonderful way to express them

Interfaces are objects that have a class and an instance. So, a Monad interface
has a ~result~ (aka ~return~) and a ~bind~ (aka ~>>=~) symbol that is
automagically called. Let's define an interface class.

#+begin_src gerbil
  (define-interface-class Monad (result bind))
  ;; => Monad::interface
#+end_src

To make an instance of an interface there is a macro, ~:~. 

#+begin_src gerbil
  (def IdentityMonad (: Monad result: identity bind: (lambda (mv mf) (mf mv))))

  ((slot-ref IdentityMonad 'bind)
   ((slot-ref IdentityMonad 'result) 1)
   (cut + 41 <>))

  ;; => 42
#+end_src

That interface is really just a wrapper for slot-ref. 

#+begin_src gerbil
  (with-interface IdentityMonad
    (bind (result 1) (cut + 41 <>)))

  ;; => 42
#+end_src

* The Symbol Bindings :: ~with-interface~

An interface has symbols, and ~with-interface~ binds those symbols. How those
symbols are described determines how they are bound.

#+begin_src gerbil 
  (import :std/srfi/19)
  (define-interface-class Test
    ((slot 'value) ;; interface-slot
     (slot-function (cut list <...>)) ;; interface-slot
     (inline inline: (slot-function slot (date->string (current-date)))) ;; interface-inline
     ((inline-function a b) (cons slot inline)) ;; interface-inline
     (alias alias: inline-function)))  ;; interface-alias
#+end_src

** ~{interface-symbol-form interface-symbol interface-binding}

Symbols need forms! Slot access needs to know the runtime binding name of the
interface itself.

#+NAME: interface-symbol-form
 #+begin_src gerbil 
  (defmethod {interface-symbol-form interface-symbol}
    (lambda (self interface-binding-name) #!void))

  (defmethod {interface-symbol-form interface-slot}
    (lambda (self name)
      `(unchecked-slot-ref ,name ',(interface-symbol-name self))))

  (defmethod {interface-symbol-form interface-inline}
    (lambda (self _)
      (interface-inline-form self)))

  (defmethod {interface-symbol-form interface-alias}
    (lambda (self _)
       (interface-alias-to-name self)))
 #+end_src

** ~with-interface~: Now we look like a static type language! yay!

#+NAME: with-interface
#+begin_src gerbil
  (defsyntax (with-interface stx)
    (def (interface-symbol->letrec*-binding interface-symbol interface-instance interface-binding)
      [(interface-symbol-name interface-symbol)
       {interface-symbol-form interface-symbol interface-binding}])
    
    (syntax-case stx (:)
      ((macro (class: form interface: interface) body ...)
       (let* ((interface-binding (gensym))
              (interface-instance (eval `(: ,(syntax->datum #'form))))
              (bindings (map (cut interface-symbol->letrec*-binding
                               <> interface-instance interface-binding)
                          {interface-symbols interface-instance})))

         (with-syntax ((rec-bindings (datum->syntax #'macro bindings))
                       (interface-let-name (datum->syntax #'macro interface-binding)))
           #'(let (interface-let-name interface) (letrec* rec-bindings body ...)))))
  ;;; If we are using the (: class ...) macro, use (class (: class ...)) as
  ;;; the interface
      ((macro (: name args ...) body ...)
       #'(macro (class: name interface: (: name args ...)) body ...))
  ;;; Now (class/interface interface) 
      ((macro (expr interface) body ...)
       (let* ((intername (gensym))
              (interform (syntax->datum #'expr))
              ;; Are we given an interface instance or a class
              (instance (with-catch (lambda (_) #f) (lambda () (eval interform)))))
         (with-syntax ((class-name (type-id (object-type (or instance (eval `(: ,interform)))))))
           #'(macro (class: class-name interface: interface) body ...))))
      ((macro (interface rest ...) body ...)
       #'(macro (interface (: interface rest ...))
           body ...))
      ((macro expr body ...)
       #'(macro (expr expr) body ...))))
#+end_src

* Interface Instance 

If we're passed a symbol, use symbol::interface. the ~:~ macro does so automagically.

#+NAME: make-interface
#+begin_src gerbil
  (def (make-interface interface . args)
    (apply make-class-instance
      (cond
       ((class-type? interface) interface)
       ((symbol? interface)
             (eval (string->symbol (string-append (symbol->string interface)
                                   "::interface"))))
       (else (object-type interface)))
      args))

  (defsyntax (: interface)
    (syntax-case interface ()
      ((macro name args ...)
       (with-syntax ((name (datum->syntax #'macro (string->symbol
                                                   (string-append (symbol->string (syntax->datum #'name))
                                                                    "::interface")))))
         #'(make-interface name args ...)))))
#+end_src

* Interface Class

#+NAME: define-interface-class
#+begin_src gerbil 
  (defsyntax (define-interface-class stx)
   (def (description-form->description form)
     (match form
       (symbol ['quote symbol])
       ([name value] ['list ['quote name] value])
       ([[name . args] . value] ['quote name])
       ([name keyword . args] ['list ['quote name] keyword . args])))

    (syntax-case stx ()
      ((macro (interface supers ...) descriptions . args)
       (with-syntax ((ds (cons 'list (map description-form->description
                                          (syntax->datum  #'descriptions))))
                     (name (datum->syntax #'macro (string->symbol
                                                   (string-append (symbol->string (syntax->datum #'interface))
                                                                  "::interface"))))
                     (super-interfaces (cons 'list (map (lambda (s)
                                                          (string->symbol
                                                           (string-append (symbol->string s) "::interface")))
                                                        (syntax->datum #'(supers ...))))))

         #'(begin (define name (make-interface-class 'interface super-interfaces ds))
                  'name)))
      ((macro class descriptions)
       #'(macro (class) descriptions))))
#+end_src

** ~make-interface-class~, where it all comes together.

We've got a name, some superclasses or instances of interfaces whose classes are
supers, and some descriptions of that the symbols should be.

Time to make a class.
#+NAME: make-interface-class
#+begin_src gerbil
  (def (make-interface-class name supers descriptions)
   (def interface-symbols (map description->interface-symbol descriptions))
   (def interface-slots (filter interface-slot? interface-symbols))

   (def interface-supers (map (lambda (s)
                                (if (class-type? s) s (object-type s)))
                              supers))
   (def (create-interface-class)
     (def slots (map interface-symbol-name interface-slots))
     (make-class-type
      name (append interface-supers [Interface::t])
      slots (string->symbol (format "Interface: ~A" name))
      [] ':init!))

   (let ((klass (create-interface-class)))
     (begin0 klass
       ;; Bind the symbols
       (bind-method! klass 'interface-symbols
                     (lambda (obj) (append interface-symbols
                                      (call-next-method klass obj 'interface-symbols))))
       ;; Bind :init!
       (bind-interface-init! klass interface-symbols))))
#+end_src

** Root Class: Interface
An interface class is made up of symbols. They all start with an actual standard
gerbil class and two methods, ~:init!~ and ~interface-symbols~.

#+NAME: defclass-interface
#+begin_src gerbil 
  (defclass Interface () constructor: :init!)

  (defmethod {:init! Interface}
    (cut class-instance-init! <...>))

  (defmethod {interface-symbols Interface}
    (lambda _ []))
#+end_src

** Interface Symbols 

An interface has symbols.

#+NAME: interface-symbols-def
#+begin_src gerbil
  (defstruct interface-symbol (name))

  (defstruct (interface-slot interface-symbol)
    (value))

  (defstruct (interface-inline interface-symbol)
    (form))

  (defstruct (interface-alias interface-symbol)
    (to-name))
#+end_src

*** Descriptions of symbols

Because there are different types of symbols, and interfaces are all about
syntax, how we describe them declares what type of symbol they are.

#+begin_src gerbil

  (def test-descriptions ['symbol ['list list] ['sequence alias: 'list]])

  (map description->interface-symbol test-descriptions)
  ;; => (#<interface-slot #15> #<interface-slot #16> #<interface-alias #17>)
#+end_src

#+NAME: description->interface-symbol
#+begin_src gerbil
  (def (description->interface-symbol description)
    (cond
     ;; If the description is just a symbol, this a reference to a slot.
     ;; Use the absent-obj so we do not have a default value.
     ((symbol? description)
      (make-interface-slot description absent-obj))
     ;; If it's a list, match it!
     ((list? description)
      (match description
        ;; (name inline: value) is inline form
        ([name inline: form] (make-interface-inline name form))
        ;; ((name . args) . body) is an inline form with (lambda args body ...)
        ([[name . args] . body] (make-interface-inline name `(lambda ,args ,@body)))
        ;; (name alias: to-name) is an alias
        ([name alias: to-name] (make-interface-alias name to-name))
        ;; otherwise, slot and default value
        ([name default] (make-interface-slot name default))))
     (else (error "Invalid Interface Description syntax"))))
#+end_src

*** ~:init!~ for default values

  If we describe a symbol as being a slot with a default value, we need to set
  it at init time. However, if we are passing in an initial value with a
  keyword, we need no default.

#+name: bind-interface-init!
#+begin_src gerbil 
  (def (bind-interface-init! klass interface-symbols)
    (bind-method! 
     klass ':init! 
     (lambda (self . args)
       (def (add-args (syms interface-symbols))
         (let* ((isym (car syms))
                (sym (interface-symbol-name isym))
                (key (symbol->keyword sym)))
           (if (and (interface-slot? isym)
                    (not (eqv? absent-obj (interface-slot-value isym)))
                    (not (member key args)))
             (set! args (append [key (interface-slot-value isym)] args))
             (unless (null? (cdr syms)) (add-args (cdr syms))))))
       (add-args)
       (apply call-next-method klass self ':init! args))))
#+end_src


* /file/ interface.ss

#+begin_src gerbil :noweb yes :tangle interface.ss
(import :gerbil/core (for-syntax :std/format) :std/iter :std/sugar :std/generic 
 (for-syntax :std/misc/rtd))
(export with-interface define-interface-class make-interface)

(begin-syntax 
 <<interface-symbols-def>>

 <<description->interface-symbol>>

 <<bind-interface-init!>>

 <<defclass-interface>>

 <<make-interface-class>>)

<<define-interface-class>>

<<make-interface>>

(begin-syntax 
  <<interface-symbol-form>>)

<<with-interface>>
#+end_src
