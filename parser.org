#+TITLE: Smug Parser  

#+begin_src gerbil :tangle "parser.ss"
  package: drewc

  (import :drewc/smug/primitive :drewc/smug/simple :drewc/smug/prefix)

  (export (import: :drewc/smug/primitive)
          (import: :drewc/smug/simple)
          (import: :drewc/smug/prefix))
#+end_src


* Introduction
  :PROPERTIES:
  :CUSTOM_ID: Introduction
  :END: 

 This library is based on an approach to building parsers using higher-order
 functions (combinators) that is popular in the functional programming
 community. Incidentally, these parsers form an instance of something called a
 monad, which is itself a useful construct with implications beyond parsing.

 With great debt to _Monadic Parser Combinators_ [1], the paper from which this
 library is derived, this tutorial presents a step by step introduction to the
 topics of *recursive descent parser combinators*, and monads(!) and their use
 in Gerbil

* How To Combine Parsers
  :PROPERTIES:
  :CUSTOM_ID: Combine
  :END:

#+BEGIN_QUOTE 
   A Parser for Things is a function from Strings to Lists of Pairs of Things and Strings!
   
   -- Fritz Ruehr, Willamette University [2]
#+END_QUOTE 

   A parser is something that is familiar to all programmers... a
   function that, given a series of tokens as input, produces a data
   structure that relates to the grammatical structure of the input in
   some way. Or, to put it simply, a function from strings to things.

   #+BEGIN_SRC lisp
  ;; our fictional parser matches the string "string" 
  ;; and returns a SYMBOL thing    
  (check (parse-thing "string") ≕> 'THING)
#+END_SRC

** Parser Type 

     We said "Lists of Pairs of Things and Strings!". In type notation[fn:1], we
     can say as follows.

     #+begin_src haskell
       type Parser thing = String -> [(thing,String)]
     #+end_src

    Why this structure? 
     
    In order to combine simple parsers into larger more complex ones, they need
    a way to communicate between them. First, because any given parser might
    consume only a part of the input, we'll have our parser return a ~pair~ with
    the result in the ~car~ and the input left over in the ~cdr~.

    #+BEGIN_SRC lisp
      ≻ (parse-thing "string string") ≕≻ (THING . " string")
    #+END_SRC

    Because a parser may return multiple results when the
    grammar is ambiguous, or may return no results all, we'll put our
    conses in a list, and have the empty list, ~[]~, denote a failed
    parse.

    #+BEGIN_SRC lisp
      ≻ (parse-thing "string string")  ≕≻ ((THING . " string"))
      ≻ (parse-thing "strong string")  ≕≻ [] 
   #+END_SRC

   It is this trivial protocol that allows us to combine small simple
   parsers into larger more useful ones.


** Primitive Parsers 

   In gerbil, we can define a function that satisfies our types declaration.

    #+begin_src gerbil 
      (def (Parser thing) (lambda (String) [[thing . String]]))

      ;;> ((Parser 'thing) "String") => ((thing . "String"))
  #+end_src
   
    That function actually becomes the first primitive parser. A function that
    takes a string and returns a list of pairs is a *Parser Value(PV)*.
  
    Because ~Parser~ is in a function that returns a *Parser Value*, it's our
    first *Parser Function(PF)*. Keeping these types in mind helps for combining
    them, and later on we'll get into more legal reasoning behind them.

*** ~(return thing)~

     To make it even more generic, rather than call it ~Parser~, the first
     parser is called ~return~.

     #+begin_src gerbil :noweb-ref return
       ;; return v = \inp -> [(v,inp)]
       (def (return v) (lambda (inp) [[v . inp]]))
     #+end_src

     That is exactly like our *Parser*. The reason that parser is a function that
     returns a function is quite simple. If we chose ~(return v inp)~, we
     couldn't close over, and we have to pass the input around. Verbosity is
     frowned upon.

     #+begin_src gerbil :noweb-ref return-test
       (check ((return 'Thing) 'String) => '((Thing . String)))
     #+end_src

     Also important to note is that is does not rely on ~String~ being a actual
     ~string?~ type. Sometimes we're not parsing strings.

*** ~(fail)~ and ~FAIL~

    There are times when we want to fail. Because we've decided that a list of
    pairs is returned from our ~PV~, if there are no pairs, the list is null.

    We'll also make a global bound ~fail~ symbol as it need not be a function,
    and it may be prettier that way, to YELL when denoting FAILURE.

    #+begin_src gerbil :noweb-ref fail
      ;; fail = \inp -> []
      (def FAIL (lambda _ []))
      (def (fail) FAIL)
    #+end_src

    #+begin_src  gerbil :noweb-ref test-fail
      (check-predicate ((fail) "") null?) 
    #+end_src


*** ~(item)~ and ~ITEM~, what makes this a parser.

     A Parser for Things is a function from Strings to Lists of Pairs of Things
     and Strings. Usually, we care about the characters is a string as
     individual items to check/lex/parse etc.

     When we parse something, ~item~ is the next thing to parse. It also moves
     the "pointer", so the next call to ~item~ is the following thing the parse.
     In certain functional languages, all the details are taken care of.

  #+begin_src haskell
    item = \inp -> case inp of
                     [] -> []
                   (x:xs) -> [(x,xs)]
  #+end_src

  We could simply emulate that. 

  #+begin_src gerbil
    (import :std/srfi/13)
    (def (item)
      (lambda (inp)
        (if (string-null? inp) []
            `((,(string-ref inp 0) . ,(substring inp 1 (string-length inp)))))))
  #+end_src

#+begin_src 
    ((item) "asd") ;=> ((#\a . "sd"))
#+end_src
  
  That does take a lot of memory that's not really needed, and I often want to
  know where I'm at, or record details as I go along.

  For the former, we can record the ~point~ what we're at as part of our new
  structure. 

  #+begin_src gerbil
    (def (item)
      (lambda (inp)
        (match (if (pair? inp) inp (cons 0 inp))
          ([n . str] (if (>= n (string-length str)) []
                             (list (cons (string-ref str n) (cons (1+ n) str))))))))
  #+end_src

  #+begin_src gerbil 
    ((item) "asd") ;=> ((#\a 1 . "asd"))
  #+end_src


  That's fine and dandy, but what if we want to parse a list of characters?
  That's a pair! How about a vector of bytes? A tree of tokens? They are not
  pairs but also not strings.

  To deal with all that and keep the mental baggage to a minimum, we'll create
  our own ~String~ structure.

  #+begin_src gerbil :noweb-ref String-struct
    (defstruct String (point thing) transparent: #t)
  #+end_src
 
  Now when a string is passed, we'll wrap in a ~String~. Beyond that, we'll use
  it to return a list of ~thing~ and ~String~.

  #+begin_src gerbil
    (def (item)
      (lambda (inp)
        (let input-item ((i inp))
          (match i
           ((String n str) 
            (if (>= n (string-length str)) []
                (list (cons (string-ref str n) (String (1+ n) str)))))
           (str (input-item (String 0 str)))))))
  #+end_src

  #+begin_src gerbil
    ((item) "asd") ;=> ((#\a . #<String #32 point: 1 thing: "asd">))
  #+end_src

  While parsing from strings is normal, and conceptually, the pairs could have
  strings on their right side, there are a tonne of reasons to make things a
  wee bit more abstract.

 We already have a generic ~ref~, which we'll steal, and use it instead of
 ~string-ref~.
 
  #+begin_src gerbil :noweb-ref item
    (defgeneric input-item-ref (lambda (t n) (ref t n)))
  #+end_src
  
  We'll also crib our own ~input-item~.

  #+begin_src gerbil :noweb-ref item
    (defgeneric input-item (cut error "No input-item declared for : " <>))
    (defmethod (input-item (str <string>)) (input-item (String 0 str)))
    (defmethod (input-item (str <pair>)) (input-item (String 0 str)))
    (defmethod (input-item (str <vector>)) (input-item (String 0 str)))
    (defmethod (input-item (str String))
      (match str
        ((String point parsee)
         (try  [(cons (input-item-ref parsee point)
                      (String (1+ point) parsee))]
               (catch (e) #;(display-exception e) [])))))
  #+end_src

  Wait a minute! ~input-item~ is a *Parser Value*! All we need for this
  primitive function is to wrap that in a function after naming it ITEM. 

  Lowercase for functions and upcase for Parser variables? Who knows. 

  #+begin_src gerbil :noweb-ref item
    (def ITEM input-item)
    (def (item) ITEM)
  #+end_src


#+begin_src gerbil :noweb-reference item-test
  (check ((item) "asd") => (ITEM "asd"))
  (check ((item) "asd") => [`(#\a . ,(String 1 "asd"))])
#+end_src

** Parser Combinators 

All we really have with the primitives is a way to take the characters and wrap
them in conses. Combining them is the entire point of ~smug~.

When we put them together, we end up looking and acting like *BNF* notation.
That helps the ol' head wrap itself around turning notation into code.

*** ~seq~: part 1, let's sequence them!

The parser returns a list which has a pair of ~Thing~ and ~String~. To put two
parser together, we could pair two things one after the other.

#+begin_src gerbil
  (def (seq p q)
    (lambda (inp)  (match (p inp)
                ([[v . inp1]] (match (q inp1)
                                ([[w . inp2]] [[[v . w] . inp2]])
                                (_ [])))
                (_ []))))

  ;; > ((seq (return 1) (item) "asd")
  ;; => (((1 . #\a) . #<String #21 point: 1 thing: "asd">))
#+end_src

That works! But, all those nested pairs (I rarely parse a string of length two),
and destructuring is an unsightly mess, there must be a better way.

*** ~bind~, part 1.

To avoid all of those nested pairs, we'll create our first *Parser Combinator*.
It lets us throw things together.

So, ~bind~ is a function that takes a *Parser Value*, extracts the ~Things~
buried inside by running the *PV* on a ~String~. Now there's a ~List~ of ~Pairs~
of ~String~'s and ~Things~. So, well run the *Parser Function* on the ~Things~.
The *PF* returns a another such list, possibly many lists, so we append them and return.

#+begin_src gerbil
  ;; p ‘bind‘ f = \inp -> concat [f v inp’ | (v,inp’) <- p inp]
  (def (bind p f)
    (lambda (inp) (append-map (cut match <> ([v . inp*] ((f v) inp*))) (p inp))))
#+end_src

This avoids the nesting so that we can combine parsers without needing to pair
them up. We could make them anything.

#+begin_src gerbil 
  (check  ((bind (item)
                (lambda (v) (bind (item)
                             (lambda (w) (bind (item)
                                          (lambda (x) (return (vector v w x))))))))
          "asd")

   =>  `((#(#\a #\s #\d) . ,(String 3  "asd"))))
#+end_src

*** ~seq~, part 2

We can implement ~seq~ using ~bind~. Doing so vice-versa is left up to the
reader.

#+begin_src gerbil
  (def (seq p q) (bind p (lambda (v) (bind q (lambda (w) (return [v . w]))))))
#+end_src

*** ~sat~, our first simple parser.

Now we can use ~bind~ to create our first non-primitive parser, ~sat~. It takes
a predicate and optionally a parser, and if the predicate it true, ~return~ the
result, otherwise ~fail~.

#+begin_src gerbil :noweb-ref sat
  ;; sat p = item ‘bind‘ \x -> if p x then return x else fail
  (def (sat predicate (parser (item)))
    (bind parser (lambda (x) (if (predicate x) (return x) (fail)))))
#+end_src

We can use it for so many things! Is it a number?

#+begin_src gerbil
  ((sat char-numeric?) "4") ;;=> ((4 . #<String #27 point: 1 thing: "4">))
#+end_src

Is it not a number? 

#+begin_src gerbil
  ((sat (? (not char-numeric?) )) "A") ;;=> ((A . #<String #28 point: 1 thing: "A">))
#+end_src

What about something not involved with ~String~?

#+begin_src gerbil
  (import :gerbil/gambit/random)

  ((sat odd? (return (random-integer 1024))) "") ;; => ((417 . ))
  ((sat odd? (return (random-integer 1024))) "") ;; => ()
#+end_src

Now, what if I wanted to combine predicates, say is it uppercase or a number? 

#+begin_src gerbil
  ((sat (? (or char-upper-case? char-numeric?))) "A")
#+end_src

Now, that's is combination. What if I wanted to return if it's a numeric char
and/or if it's a string of two numbers? Our parsers are combinators. Logically
we could try to pair them up.

#+begin_src gerbil
  ((bind (sat char-numeric?)
        (lambda (c) (bind (item)
                (lambda (d) (return
                        (if (not (char-numeric? d)) c
                          (cons c (list->string [c d])))))))) "42")
 ;; => (((4 . 42) . #<String #19 point: 2 thing: "42">))
#+end_src

 But that runs into the same problems as our ~seq~ combinator. Time for another
 primitive.

*** ~++~, Part 1: Add (combine?!) parsers together

Adding simply means appending the two ~List~'s.

#+begin_src gerbil 
  ;; p ++ q = \inp -> (p inp ++ q inp)
  (def (++ p q) (lambda (inp) (append (p inp) (q inp))))
#+end_src

So, the two results are not paired, but rather two items in the list.

#+begin_src gerbil
  ((++ (sat char-numeric?)
               (bind (sat char-numeric?)
                     (lambda (x) (bind (sat char-numeric?)
                                       (lambda (y) (return (list->string [x y]))))))) "42")
  ;; => ((#\4 . #<String #21 point: 1 thing: "42">)
  ;;;    ("42" . #<String #22 point: 2 thing: "42">))
#+end_src

We are now introduced to /non-determinism/, so it's also time to use /recursive
descent/.

Let's say we want a word that could be every letter, or a few two-char numbers.

#+begin_src gerbil
  (def two-char-number
    (bind (sat char-numeric?)
          (lambda (x) (bind (sat char-numeric?)
                       (lambda (y) (return (string->number (list->string [x y]))))))))

  (def item-or-number? (++ (item) two-char-number))

  (def (word-or-number (p item-or-number?))
    (++ (bind p
              (lambda (x) (bind (word-or-number p)
                           (lambda (xs) (return [x . xs])))))
        (return [])))
#+end_src

Running that gives a 22 item list as ~word-or-number~ recursively builds it.

#+begin_src gerbil
  ((word-or-number) "4242 a") ;; =>
  (((#\4 #\2 #\4 #\2 #\space #\a) . #<String #16 point: 6 thing: "4242 a">) ((#\4 #\2 #\4 #\2 #\space) . #<String #17 point: 5 thing: "4242 a">)
  ;; [...]
   ((#\4 24 #\2 #\space #\a) . #<String #24 point: 6 thing: "4242 a">) ((#\4 24 #\2 #\space) . #<String #25 point: 5 thing: "4242 a">) ((#\4 24 #\2) . #<String #26 point: 4 thing: "4242 a">) ((#\4 24) . #<String #27 point: 3 thing: "4242 a">)
   ((42 #\4 #\2 #\space #\a) . #<String #29 point: 6 thing: "4242 a">) ((42 #\4 #\2 #\space) . #<String #30 point: 5 thing: "4242 a">)
  ;; [...]
   ((42 42 #\space) . #<String #34 point: 5 thing: "4242 a">) ((42 42) . #<String #35 point: 4 thing: "4242 a">) ((42) . #<String #36 point: 2 thing: "4242 a">) (() . "4242 a"))
#+end_src

Wow! What becomes interesting is the simple fact that it's /non-deterministic/
and keeps on trying. This means that the number 24 can appear.

Without the ~item-or-number?~, the parser will only return the 42's. Because we
have item there, it tries a ~two-char-number~ after it ~(item)~'s the *#\4*.

So we can write a parser that looks for 24.

#+begin_src gerbil
  (def extract-24
    (sat (cut member 24 <>) (word-or-number)))

  (extract-24 "4242 a")
  ;; =>
  (((#\4 24 #\2 #\space #\a) . #<String #37 point: 6 thing: "4242 a">)
   ((#\4 24 #\2 #\space) . #<String #38 point: 5 thing: "4242 a">)
   ((#\4 24 #\2) . #<String #39 point: 4 thing: "4242 a">)
   ((#\4 24) . #<String #40 point: 3 thing: "4242 a">))
#+end_src


** ~.let*~, ~:P~ syntax for and in ~bind~. 

We've starting stringing ~bind~'s and ~lambda~'s together like no tomorrow.
Similar to ~seq~ /vs/ ~bind~, parsing should not be a headache to look at.

There's a whole bunch of ~do~ and ~<-~ arrow like comprehension syntax out
there, but it the end it's just like ~let*~, or in our case, ~let*~.

Here's an example. First, a normal way.


#+begin_src gerbil
  (import :gerbil/gambit/random)
  (let* ((x (random-integer 42)) (y (+ x (random-real))))
    (- (random-integer 42) y))
#+end_src
Although that's not likely to be a parser, it could be, and translating it becomes verbose. 

#+begin_src gerbil 
    (bind (return (random-integer 42))
          (lambda (x) (bind (return (+ x (random-real)))
                       (lambda (y) (return (- (random-integer 42) y)))))))
#+end_src

To start things off, *BNF* notation was mentioned. This is nowhere near that.
Syntax to the rescue.

First things first, create a syntax to expand to.

#+begin_src gerbil
  (defsyntax (.let* stx)
    (syntax-case stx ()
      ((macro bind: id to: PV body ...)
       (datum->syntax
           #'macro
         `(bind ,(syntax->datum #'PV)
                (lambda (,(syntax->datum #'id)) ,@(syntax->datum #'(body ...))))))))
#+end_src

Doing that does not really improve the verbosity, but it does give us something
to expand to.

#+begin_src gerbil
  ((.let* bind: foo to: (return 1) 
                 (return (+ foo 42))) "")
  => ((43 . ""))
#+end_src

We'll use that to give us a "normal" ~let~ form.

#+begin_src gerbil
  (defsyntax (.let* stx)
    (syntax-case stx ()
     ;;; First the hidden bind: to:
      ((macro bind: id to: PV body ...)
       (datum->syntax
           #'macro
         `(bind ,(syntax->datum #'PV)
                (lambda (,(syntax->datum #'id)) ,@(syntax->datum #'(body ...))))))
    ;;; Now the ((v ...) (w ...)) type that recursively expands.
      ((macro ((id value) rest ...) body ...)
       #'(macro bind: id to: value
                (macro (rest ...) body ...)))
      ((macro (id value) body ...) #'(macro ((id value)) body ...))
      ((macro _ body ...)
       #'(begin body ...))))
#+end_src

That helps us get close.

#+begin_src gerbil
  ((.let* ((x (return (random-integer 42))) (y (return (+ x (random-real)))))
     (return (- (random-integer 42) y)))
   "")
  ;; => ((-6.62558545920108 . ""))
#+end_src

Those ~return~'s are still making noise, and we like sugar. The first 2 will be
solved first, and the last latter.

*** ~:P~  syntax and ~ensure-parser(thing inp)~.

 So, what is a parser? Well, it's a function from strings to ... wait...

 We want things shorthanded, yet not intrusive. So, we can represent a parser
 another way, and turn it into a *PV*.

 So, the following items become parsers.
  
  - a procedure :: Already a parser (we hope).
  - a character :: ~#\f~ is ~(sat (cut char=? <> #\f))~.
  - a string :: "foobar" is that char match recursively.
  - ~#!eof~ :: When ~(item)~ fails.
  - a boolean :: returns itself.
  - a null? list :: returns itself.
  - a void value :: Yup, itself.
  - anything else :: passed to ~ensure-parser~, a generic that takes the value
                     and the input. By default, it returns the value.

 #+begin_src gerbil :noweb-ref p-ensure-parser
   (defgeneric ensure-parser
     (lambda (thing inp)
       ((return thing) inp)))

   (defsyntax (:P stx)
     (syntax-case stx ()
       ((macro v)
        (let* (v (syntax->datum #'v))
          (datum->syntax #'macro 
            `(:P ,(cond
                   ((char? v) char:)
                   ((string? v) string:)
                   (((? (or boolean? void? null?)) v) return:)
                   ((eof-object? v) eof:)
                   (#t ensure:))
                 ,v))))

       ((macro char: c)
        #'(sat (cut char=? <> c)))
       ((macro return: v) #'(return v))
       ((macro eof: v) #'(lambda (i) (match (ITEM i)
                                  ([] [[v . i]])
                                  (t []))))
       ((macro ensure: thing)
        #'(let (v thing)
            (cond
             ((procedure? v) v)
             ((char? v) (:P char: v))
             ((string? v) (:P string: v))
             (((? (or boolean? void? null?)) v) (:P return: v))
             ((eof-object? v) (:P eof: v))
             (#t (cut ensure-parser v <>)))))
       ((macro string: str)
        (let* ((v (syntax->datum #'str))
               (lst? (and (string? v) `(quote ,(string->list v))))
               (str (gensym)) (lst (gensym)) (cs (gensym)))
          (datum->syntax #'macro 
            `(let* ((,str ,v) (,lst ,(or lst? `(string->list ,str))))
               (let str? ((,cs ,lst))
                 (if (null? ,cs) (return ,str)
                     (bind (:P char: (car ,cs))
                           (lambda _ (str? (cdr ,cs))))))))))))
 #+end_src

*** ~.let*~ with ~:P~'s

  Using  ~:P~ for let* really helps to clear up the syntax

  #+begin_src gerbil :noweb-ref .let*
    (defsyntax (.let* stx)
      (syntax-case stx ()
       ;;; First the hidden bind: to:
        ((macro bind: id to: PV body ...)
         (datum->syntax
             #'macro
           `(bind (:P ,(syntax->datum #'PV))
                  (lambda (,(syntax->datum #'id)) ,@(syntax->datum #'(body ...))))))
      ;;; Now the ((v ...) (w ...)) type that recursively expands.
        ((macro ((id value) rest ...) body ...)
         #'(macro bind: id to: value
                  (macro (rest ...) body ...)))
        ((macro (id value) body ...) #'(macro ((id value)) body ...))
        ((macro _ body ...)
         #'(begin body ...))))
  #+end_src

  Remember the normal form, eh?

 #+begin_src gerbil
   (let* ((x (random-integer 42)) (y (+ x (random-real))))
     (- (random-integer 42) y))
 #+end_src

 We get even closer.

  #+begin_src gerbil
    ((.let* ((x (random-integer 42)) (y (+ x (random-real))))
       (return (- (random-integer 42) y)))
     "")
    ;; => ((-6.62558545920108 . ""))
  #+end_src

*** ~bind~, Part 2: now with ~:P~ and a special ~return~!

     We still need that extra return. 
     
     Normal: 

     #+begin_src gerbil
   (let (x (if (odd? (random-integer 42)) #\o #\e))
     (string x))
   ;; => "e" OR "o"
     #+end_src

     Us: 

     #+begin_src gerbil
   ((.let* (x (if (odd? (random-integer 42)) #\o #\e))
     (return (string x))) "e")
   ;; => => ((e . #<String point: 1 thing: "e">)) OR ()
    #+end_src
 Now, we could just wrap a ~:P~ like we do for the bindings. But often we want
 to return a char or a string, not a parser for such.

 So, it very simple. A parser is a function. If we want to return a function, we
 use ~return~, which of course returns that function as a *Parser Value*.

 Regardless, We'll check the return value of the *Parser Function*, and wrap a
 ~return~.

#+begin_src gerbil 
  (def (bind p f)
    (def sugarPF (lambda (v) (let (r (f v)) (if (procedure? r) r (return r)))))
    (lambda (inp) (append-map
              (cut match <> ([v . inp*] ((sugarPF v) inp*))) ((:P p) inp))))
#+end_src

Now our ~bind~ has a short form.

*Long:*
 #+begin_src gerbil
   ((bind (sat (cut char=? <> #\a)) (lambda _ (return 42))) "abc")
   ;; => ((42 . #<String point: 1 thing: "abc">))
 #+end_src

*Short:*

#+begin_src gerbil
  ((bind #\a (lambda _ 42)) "abc") ;; => ((42 . #<String point: 1 thing: "abc">))
#+end_src

And it does not turn string or chars into parsers.

#+begin_src gerbil
  ((bind (sat (cut char=? <> #\a)) (lambda _ (return #\z))) "abc")
  ;;   /vs/ 
  ((bind #\a (lambda _ #\z)) "abc")

  ;; => ((z . #<String point: 1 thing: "abc">))

  ;; and

  ((bind (sat (cut char=? <> #\a)) (lambda _ (sat (cut char=? <> #\z)))) "az42")
  ;; /vs/
  ((bind #\a (lambda _ (sat (cut char=? <> #\z)))) "az42")
  ;; or even better
  ((bind #\a (lambda _ (bind #\z identity))) "az42")

  ;; => ((z . #<String  point: 2 thing: "az42">))
#+end_src

And because ~.let*~ uses ~bind~ underneath, we can get rid of that final ~return~.

     #+begin_src gerbil
       ((.let* (x (if (odd? (random-integer 42)) #\o #\e)) (string x))
        "e")
       ;; => => ((e . #<String point: 1 thing: "e">)) OR ()
    #+end_src

*** ~++~, Part 2 

   ~++~ is also primitive. We need that wrapping *:P*'aper.

#+begin_src gerbil :noweb-ref ++
  ;; p ++ q = \inp -> (p inp ++ q inp)
  (def (++ p q) (lambda (inp) (append ((:P p) inp) ((:P q) inp))))
#+end_src

  #+begin_src gerbil
    ((++ #\f "foobar") "foobarbaz")
      ;;; =>
    ;; ((#\f . #<String point: 1 thing: "foobarbaz">)
    ;;  (foobar . #<String point: 6 thing: "foobarbaz">))
  #+end_src

** ~.list=~ and predicate friends. 

   *SRFI 1* has ~(list= elt= list ...)=~. The gerbil version seems to have the
   predicate optional.

   Performance sometimes matters, so optionally we will not build and return the
   parsed list.

  #+begin_src gerbil :noweb-ref predicates
    (def* .list=
      ((lst) (.list= equal? lst #t))
      ((pred-or-list list-or-bool)
       (.list= (if (list? pred-or-list) equal? pred-or-list)
               (if (list? pred-or-list) pred-or-list list-or-bool)
               (if (list? pred-or-list) list-or-bool #t)))
      ((elt= lst return-parsed?)
       (let l= ((cs lst))
         (if (null? cs) (return [])
             (.let* ((c (sat (cut elt= <> (car cs))))
                     (cs (l= (cdr cs))))
               (if return-parsed? (cons c cs) lst))))))
  #+end_src

  The variable args allow us to decide what we want.
  
  #+begin_src gerbil :noweb-ref test-.list=
    (def test-.list=
      (.let* (
             ;; the default is char=?
             (lst (.list= '(#\a #\s)))
             ;; If we have a list, we can parse that
             (the-list (return '(#\d)))
             ;; if an arg after the list is #f, we don't collect the parsed list,
             ;; and return the list we passed
             (also-the-list (.list= the-list #f))
             ;; If the first argument is a predicate, use that on the chars.
             (case-in (.list= char-ci=? '(#\F #\G)))
             ;; same thing for the #f
             (the-case-in (return '(#\H #\J)))
             (also-the-case-in (.list= char-ci=? the-case-in #f)))


        [lst the-list also-the-list case-in the-case-in also-the-case-in]))

    (let (r (test-.list= "asdfghjkl;"))
      (match r
        ([[res . Str]]
         (check Str => (String 7 "asdfghjkl;"))
         (match res
           ([lst the-list also-the-list case-in the-case-in also-the-case-in]
            (check lst => '(#\a #\s))
            (check the-list => '(#\d))
            (check-eq? the-list also-the-list)
            (check case-in => '(#\f #\g))
            (check also-the-case-in => '(#\H #\J))
            (check-eq? the-case-in also-the-case-in))))))

  #+end_src


*** ~string=~, ~:P~ is not the only way to test strings.

    We just made ~:P~, and it has within it a parser for a string.

    #+begin_src gerbil
   (@expand1 (:P string: "asd"))
   ;; => 
   ;; (let* ((#:g20770 "asd") (#:g20771 '(#\a #\s #\d)))
   ;;   (let str? ((#:g20772 #:g20771))
   ;;     (if (null? #:g20772)
   ;;         (return #:g20770)
   ;;         (bind (:P char: (car #:g20772)) (lambda _ (str? (cdr #:g20772)))))))
 #+end_src

    So, the easy way to create ~.string=?~ is by using it.

    #+begin_src gerbil :noweb-ref predicates
      (def (.string=? str (start #f) (end #f))
        (:P string:
            (if (not (or start end)) str
                (substring
                 str (or start 0) (or end (string-length str))))))
   #+end_src

   Now, that's a really nice thing to have around, especially when we want to
   return a parser and not a string, which we did specifically avoid after all.

   But at the same time, we may want something like case-insensitivity, which is
   the primary use of this. We may want to return the string parsed, not the
   string predicated towards.

   ~.list=~ to the rescue,  to father ~.string=~ mating with ~P:string=~.

   ~P:string=~ breaks it up into keywords. Just like we did for ~.let*~.

 #+begin_src gerbil :noweb-ref predicates
   (def (P:string= str pred: (pred char=?) start: (start #f) end: (end #f)
                   return-parsed: (r? #t))
     (def lst (string->list
               (if (or (not (or start end))
                       (and (eqv? start 0) (not end)))
                str
                (substring str (or start 0) (or (and (number? end) end) (string-length str))))))

     (.let* (l (.list= pred lst r?))
       (if r? (list->string l) str)))
 #+end_src

   Just like ~.list=~, we'll have the arg types determine what is passed. 

 #+begin_src gerbil :noweb-ref predicates
   (def (.string= pred-or-str (str-or-n-or-b (void))
                  (n-or-b (void))
                  (en-or-b (void))
                  (r? (void)))
    (let ((str (if (string? pred-or-str) pred-or-str str-or-n-or-b))
          (pred (if (string? pred-or-str) char=? pred-or-str))
          (start (if (number? str-or-n-or-b) str-or-n-or-b
                     (if (number? n-or-b) n-or-b (if (number? en-or-b) en-or-b #f))))
          (end (if (string? pred-or-str)
                 (if (number? str-or-n-or-b)
                   n-or-b
                   (if (number? en-or-b) en-or-b #f))
                 #f))
          (r? (if (boolean? r?) r?
                  (if (boolean? en-or-b) en-or-b
                      (if (boolean? n-or-b) n-or-b
                          (if (boolean? str-or-n-or-b) str-or-n-or-b #t))))))
        (P:string= str pred: pred start: start end: end return-parsed: r?)))
 #+end_src

  #+begin_src gerbil :noweb-ref test-.string=
    (def test-.string=
      (.let* (
             ;; the default is char=?
             (str (.string= "as"))
             ;; If we have a string, we can parse that
             (the-string (return "d"))
             ;; if an arg after the string is #f, we don't collect the parsed list,
             ;; and return the string we passed
             (also-the-string (.string= the-string #f))
             ;; If the first argument is a predicate, use that on the chars.
             (case-in (.string= char-ci=? "FG"))
             ;; same thing for the #f
             (the-case-in (return "HJ"))
             (also-the-case-in (.string= char-ci=? the-case-in #f))
             (start-sub (.string=  "1111111kl;" 7))
             (the-sub (return "01aa"))
             (also-the-sub (.string= the-sub 1 2 #f))
             (final-sub (return "asd234"))
             (also-final-sub (.string= char=? final-sub 3 #f)))


        [str the-string also-the-string case-in the-case-in also-the-case-in
             start-sub the-sub also-the-sub final-sub also-final-sub]))

    (let (r (test-.string= "asdfghjkl;1234"))
      (match r
        ([[res . Str]]
         (check Str => (String 14 "asdfghjkl;1234"))
         (match res
           ([str the-string also-the-string case-in the-case-in also-the-case-in
                 start-sub the-sub also-the-sub final-sub also-final-sub ]
            (check str => "as")
            (check the-string => "d")
            (check-eq? the-string also-the-string)
            (check case-in => "fg")
            (check also-the-case-in => "HJ")
            (check-eq? the-case-in also-the-case-in)
            (check start-sub => "kl;")
            (check-eq? the-sub also-the-sub)
            (check-eq? final-sub also-final-sub))))))

  #+end_src

**** ~.string-ci=?~ and friends.

     Case insensitivity was the whole point. 

 #+begin_src gerbil :noweb-ref predicates
   (def (.string-ci=? str . args) (apply .string= char-ci=? str args))
 #+end_src

    As a matter of fact, that can be used to make ~string>~ and the like, which
    may happen here at some point.


* Combinators for repetition
  :PROPERTIES:
  :header-args: :noweb-ref test-c-for-rep
  :CUSTOM_ID: comb_rep
  :END:

Because of ~++~ and recursion, we already have ~.list=~, which is a recursive
descent parser. Because that recursion is so common, with building a list along
the way going hand in hand, there is, of course, a short way to do it.

** Simple Repetition

Starting from the root, let's say we want a list of numbers.


#+begin_src gerbil
  (def (many-numbers)
   (++ (.let* ((n (sat char-numeric?)) (ns (many-numbers))) [n . ns]) []))
#+end_src
That's a fairly simple definition, and does start to show off certain features of smug.

#+begin_src gerbil
  ((many-numbers) "01234asd")
  ;; =>
  ;; (((#\0 #\1 #\2 #\3 #\4) . #<String #51 point: 5 thing: "01234asd">)
  ;;  ((#\0 #\1 #\2 #\3) . #<String #52 point: 4 thing: "01234asd">)
  ;;  ((#\0 #\1 #\2) . #<String #53 point: 3 thing: "01234asd">)
  ;;  ((#\0 #\1) . #<String #54 point: 2 thing: "01234asd">)
  ;;  ((#\0) . #<String #55 point: 1 thing: "01234asd">) 
  ;;  (() . "01234asd"))
#+end_src

The first thing to notice is that ~++~ returns every portion of the list. That
can mean some great things for parsers. We already have one that parses many
numbers. 

Let's combine with it. Something like "Many numbers followed by a 0 or a .".

#+begin_src gerbil
  (def (many-combo-thingie)
    (.let* ((ns (many-numbers))
            (post (++ #\0 #\.)))
      [ns: ns post: post]))

  ;; ((many-combo-thingie) "012340054321.0asd")
  ;; =>
  ;; (((ns: (#\0 #\1 #\2 #\3 #\4 #\0 #\0 #\5 #\4 #\3 #\2 #\1) post: #\.)
  ;;   . #<String point: 13 thing: "012340054321.0asd">)
  ;;  ((ns: (#\0 #\1 #\2 #\3 #\4 #\0) post: #\0)
  ;;   . #<String point: 7 thing: "012340054321.0asd">)
  ;;  ((ns: (#\0 #\1 #\2 #\3 #\4) post: #\0)
  ;;   . #<String point: 6 thing: "012340054321.0asd">)
  ;;  ((ns: () post: #\0)
  ;;   . #<String point: 1 thing: "012340054321.0asd">))
#+end_src

We can combine that again. Our parser is for decimal numbers.

#+begin_src gerbil
  (def DecimalDigit
    (.let* ((thingie (many-combo-thingie))
            (dec (if (not (char=? (pget post: thingie) #\.)) (fail)
                     (many-numbers))))
      (string->number
       (list->string (append (pget ns: thingie) '(#\.) dec)))))

  ;; >  (DecimalDigit "012340054321.1asd")
  ;; => 
  ;; ((1.23400543211e10 . #<String point: 14 thing: "012340054321.0asd">)
  ;;  (1.2340054321e10 . #<String point: 13 thing: "012340054321.0asd">))
#+end_src

One has nothing after the decimal place, the first has 1. Because many numbers
can return a nothing list. 

*** ~many~ times, a parser, part 1.

Abstracting what we have is quite simple, yet gives us so much leeway in what we
parse and how we parse it.

#+begin_src gerbil :noweb-ref c-for-rep
  (def (many p) (++ (.let* ((x p) (xs (many p))) [x . xs]) []))
#+end_src

We can use that to make ~many-numbers~. Just like that parser, it returns many
results in decreasing order. Because of what a *PV* is, a list of pairs, every
one of those will be applied to the next. Though this is often desirable, often
we only want the first, like DecimalDigit. The next section will deal with this
and other efficiency issues with our current approach.

So, using ~many~, We'll make a parser for an *IdentifierName*. It must start
with a letter, then it can have numbers.

#+begin_src gerbil
  (def IdentifierName
    (.let* ((x (sat char-alphabetic?))
            (xs (many (sat (? (or char-alphabetic? char-numeric?
                                  (cut char=? <> #\_)))))))
      (list->string [x . xs])))

  ;; (IdentifierName "A_123")
  ;; =>
  ;; (("A_123" . #<String point: 5 thing: "A_123">)
  ;;  ("A_12" . #<String point: 4 thing: "A_123">)
  ;;  ("A_1" . #<String point: 3 thing: "A_123">)
  ;;  ("A_" . #<String point: 2 thing: "A_123">)
  ;;  ("A" . #<String point: 1 thing: "A_123">))
#+end_src

*** ~many1~, because empty is boring

Because ~many~ will return an empty list, and often we want success of the
parser to determine if we proceed, ~many1~ is the solution.
 
#+begin_src gerbil :noweb-ref c-for-rep
  (def (many1 p) (.let* ((x p) (xs (many p))) [x . xs])) 
#+end_src

Using that, we'll create a parser, ~Nat~, for natural numbers.

#+begin_src gerbil
  (def Nat (.let* (ns (many1 (sat char-numeric?))) 
             (string->number (list->string ns))))

  ;; (Nat "42") => ((42 . #<String #70 point: 2 thing: "42">)
  ;;                (4 . #<String #71 point: 1 thing: "42">))
#+end_src

In turn, ~Int~ can combine ~Nat~ and the possibility of it being negative.

#+begin_src gerbil
  (def Int (++ Nat (.let* ((_ #\-) (n Nat)) (- n))))

  ;; (Int "-42") => ((-42 . #<String point: 3 thing: "-42">)
  ;;                 (-4 . #<String point: 2 thing: "-42">))
#+end_src


** Repetition with separators

   I need this all the time. Sometimes, things are separated, but not really
   divided, and, in fact, may run on, and on, and on... eh?

   If we want a list of ~Int~'s, we have the will and the way.

   #+begin_src gerbil
     (def Ints
       (.let* ((_ "(")
               (n Int)
               (ns (many (.let* (_ #\,) Int)))
               (_ ")"))
         [n . ns]))

     ;; (Ints "(-42)") => (((-42) . #<String point: 5 thing: "(-42)">))
     ;; (Ints "(-42,42,420)") => (((-42 42 420)
     ;;                            . #<String point: 12 thing: "(-42,42,420)">))
   #+end_src

   Just like ~many-numbers~ transformed into ~many~, it can be abstracted and
   used for many things.

*** ~sepby1~

    We'll start the other way around, and make one that must succeed first.

    #+begin_src gerbil :noweb-ref sepby
      (def (sepby1 p sep)
        (.let* ((x p) (xs (many (.let* ((_ sep) (y p)) y)))) [x . xs]))

      ;; ((sepby1 Int ",") "-42,42,420")
      ;; => (((-42 42 420) . #<String point: 10 thing: "-42,42,420">)
      ;;     ((-42 42 42) . #<String point: 9 thing: "-42,42,420">)
      ;;     ((-42 42 4) . #<String point: 8 thing: "-42,42,420">)
      ;;     ((-42 42) . #<String point: 6 thing: "-42,42,420">)
      ;;     ((-42 4) . #<String point: 5 thing: "-42,42,420">)
      ;;     ((-42) . #<String point: 3 thing: "-42,42,420">)
      ;;     ((-4) . #<String  point: 2 thing: "-42,42,420">))
    #+end_src

    That can now by used for ~Ints~
    
   #+begin_src gerbil
     (def Ints
       (.let* ((_ "(")
               (ns (sepby1 Int #\,))
               (_ ")"))
         ns))
   #+end_src

*** ~bracket~

   Reduction of things has been the name of the game. Just like ~:P~ and
   ~.let*~, we can go further.

   #+begin_src gerbil :noweb-ref sepby
     (def (bracket open p close) (.let* ((_ open) (x p) (_ close)) x))
   #+end_src

   Using that, our ~Int~ becomes trivial.
   
   #+begin_src gerbil
     (def Ints (bracket #\( (sepby1 Int #\,) #\)))
   #+end_src
  
*** ~sepby~, like ~many~, always succeeds. 

    Like we used ~many~ to define ~many1~, ~sepby1~ can give us ~sepby~.

    #+begin_src gerbil :noweb-ref sepby
      (def (sepby p sep) (++ (sepby1 p sep) []))
    #+end_src


** Repetition with meaningful separators

   This is luck! On my *TODO* list is some parsing of arithmetic expressions.
   So, this section in *MPC*[fn:1] is all about that, and exports some
   combinators from Fokker (1995) [fn:fokker].

   #+begin_quote

Consider the problem of parsing simple arithmetic expressions such as
1+2-(3+4), built up from natural numbers using addition, subtraction,
and parentheses. The two arithmetic operators are assumed to associate
to the left (thus, for example, 1-2-3 should be parsed as (1-2)-3),
and have the same precedence. The standard BNF grammar for such
expressions is written as follows:


  expr  ::= expr addop factor | factor
  addop ::= + | -
  factor ::= + | nat | ( expr ) 
 #+end_quote

   We can translate them to directly to smug.

   #+begin_src gerbil
     (def expr (++ (.let* ((x expr) (f addop) (y factor)) (f x y))
                     factor))
     (def addop (++ (.let* (_ #\+) (return +)) (.let* (_ #\-) (return -))))
     (def factor (++ Nat (bracket #\(expr#\))))
   #+end_src

   It's really nice! The ~expr~ actually evaluates things. But, it calls itself,
   first. This sort of thing, *left-recursion*, is not uncommon in grammars. But
   it runs forever. Not what we want.

   Not only that, but trying to define variables using undefined variables.
   That's not going to work.

   To make it right for the compiler, only ~addop~ stays the same.
   #+begin_src gerbil 
     (def addop (++ (.let* (_ #\+) (return +)) (.let* (_ #\-) (return -))))
   #+end_src

   The first attempt to make ~factor~ and ~expr~ function is to make then into
   functions. That's because functions reference at run time, and can reference
   themselves.

   #+begin_src gerbil
  (def (factor) (++ Nat (bracket #\((expr)#\))))
  (def (expr)
    (.let* ((x (factor)) (fys (many (.let* ((f addop) (y (factor))) [f . y]))))
      [x . fys]))
   #+end_src
   
   Yet I have to admit, though that looks fine, it's also infinitely recursive. F*#k!

   So, to deal with it is simple. All parser values are in fact functions. Even
   better, ~.let*~ can automagically make a function that references an
   identifier at run-time.

   Remember that ~let*~ expands to ~(bind PV PF)~. So, we can choose to
   reference within the *PF*, which is run only after the *PV* succeeds.

   In short: 

   #+begin_src gerbil
     (import :std/interactive)
     (@expand (.let* ((_ (void))) this-is-a-lambda))
     ;; => (bind (:P (void)) (lambda (_) (.let* () this-is-a-lambda)))

     (@expand (.let* () this-is-a-lambda))
     ;; => (%#begin (%#ref this-is-a-lambda))

     ;; with total macroexpand:
     ;; => (bind (return (void)) (lambda (_) (%#begin (%#ref this-is-a-lambda))))
  #+end_src

  Using that cheat, we can make them all variables, not add the extra irritating
  parens, and make our syntax more grammatical.
  

   #+begin_src gerbil 
     (def factor Nat)
     (def addop (++ (.let* (_ #\+) (return +)) (.let* (_ #\-) (return -))))
     (def expr
       (.let* (;;; this makes the rest a function that references factor so we can
               ;;; set! it.
               (_ #!void))
               ;;; We are now in a "Thunk"
               (x factor)
               (fys (many (.let* ((f addop) (y factor)) [f . y]))))
              [x . fys]))

     ;; and now we set it.
     (set! factor (++ Nat (bracket #\( expr #\))))


   #+end_src
   Yeah! Bare symbols allow use of non-verbose sugar. But this section is about
   giving meaning to the separators. We keep ~addop~, and it's a function. So,
   running ~(expr "1-2+3-4")~ makea ~x = 1~ and ~fys = (#<procedure -> . 2)
   (#<procedure +> . 3) (#<procedure -> . 4)~.

   This is scheme, and that list cries out to be folded. In doing so, we'll run
   the ~addop~ function.

   #+begin_src gerbil 
     (def expr
       (.let* ((_ #!void) (x factor)
               (fys (many (.let* ((f addop) (y factor)) [f . y]))))
         (foldl (lambda (fy x) (match fy ([f . y] (f x y)))) x fys)))
   #+end_src

   #+begin_src gerbil
     (check (caar (expr "1+2-3+4")) => 4)
     (check (caar (expr "(1+2)-(3+4)")) => -4)
     (check (caar (expr "(1)+(2-3+4)")) => 4)
     (check (caar (expr "1+2-(3+4)")) => -4)
     (check (caar (expr "(1)+(2-3)+(4)")) => 4)
   #+end_src
  
   That operation is common enough that a combinator, ~chainl1~, does just that.

   #+begin_src gerbil
     (def (chainl1 p op)
       (.let* ((x p) (fys (many (.let* ((f op) (y p)) [f . y])))()
         (foldl (lambda (fy x) (match fy ([f . y] (f x y)))) x fys)))
   #+end_src

   
   Our parser syntax becomes shorter.

   #+begin_src gerbil 
     (def factor Nat)
     (def addop (++ (.let* (_ #\+) (return +)) (.let* (_ #\-) (return -))))
     (def expr (.let* ((_ (void))) (chainl1 factor addop)))
     (set! factor (++ Nat (bracket #\( expr #\))))
   #+end_src

   Notice the repetition in ~addop~? That's also quite common, so we'll make a combinator, ~op~, for that as well. 
   
   #+begin_src gerbil
     (def (ops . pairs)
       (def op (cut match <> ([p . op] (.let* (_ p) (return op)))))
       (foldr ++ FAIL (map op pairs)))
   #+end_src

   All we're doing is making a list of ~[parser . operator]~ into a nested ~++~. That allows more shorthand.

   #+begin_src gerbil
     (def addop (ops [#\+ . +] [#\- . -]))
   #+end_src

   Efficiency is a concern. Syntax and short-forms usually come second to "make
   it fast!". That's why ~.list=~ and friends can not build things.

   ~many~ builds a list that we then fold. We can avoid that entirely by
   redefining ~chainl1~.

   #+begin_src gerbil
     (def (chainl1 p op)
       (def (chain-link x)
         (++ (.let* ((f op) (y p)) (chain-link (f x y))) (return x)))
       (bind p chain-link))
   #+end_src

   Remember our ~Nat~? We build a list there as well. We don't have to when
   using ~chainl1~ The extra ~let n ()~ is just to be able to type ~def~ for
   locally definitions.

   #+begin_src gerbil
     (def Nat
       (let n () (def (op m n) (+ (* m 10) n))
         (def digit (.let* (n (sat char-numeric?)) (string->number (string n))))
         (chainl1 digit (return op))))
   #+end_src

   Of course, some things are the opposite. So, while *+/-* are
   left-associative, *^*, for exponents, associates to the right.

   #+begin_src gerbil 
     (def (chainr1 p op)
       (.let* (x p)
         (++ (.let* ((f op) (y (chainr1 p op))) (return (f x y)))
             (return x))))
   #+end_src


   Now that we have all that, we can make a more readable, more performant, and
   more *BNF* like parser definition.

   #+begin_src gerbil 
     (def AddOp (ops [#\+ . +] [#\- . -]))
     (def ExpOp (ops [#\^ . expt]))
     (def Factor #f)
     (def Term (cut (chainr1 Factor ExpOp) <>))
     (def Expr (chainl1 Term AddOp))
     (set! Factor (++ Nat (bracket #\( Expr #\))))
   #+end_src


   #+begin_src gerbil
     (check (caar (Expr "(2^3)+2-1")) => 9)
   #+end_src


   We were able to get right of the left-recursion and excess list creation, but
   we still return a lot of results. For every term, a result is returned.

   #+begin_src gerbil
     (check (length (Expr "1+2-(3^4)+(5)")) => 4)
   #+end_src


   Also, our ~++~ and our ~many~ are both greedy and overbearing. This is
   partially due to our design, and partially due to the language. This will be
   covered in the next section.


* Efficiency of parsers

The entire reason behind *smug* is a nice way to look at parser definitions
while still being a part of the programming language. Beyond the syntax ~.let*~
and the rarely used ~:P~, we are just normal syntax.

But, a lot of the documentation on parsers, like *MPC*'s[fn:1] is based on
functional languages where the compiler is lazy, and things are only run when
needed.

So, while left-factoring and moving things around help for translation, there
are some fundamental issues. We'll get over those here, and create an easy to
use, easy to view, and, ehem, easy to debug.

** Left factoring 

   Let's say we want a parser for addition or subtraction.

   #+begin_src gerbil
     (def (meval)
       (def add (.let* ((x Nat) (_ #\+) (y Nat)) (+ x y)))
       (def sub (.let* ((x Nat) (_ #\-) (y Nat)) (- x y)))
       (++ add sub))
   #+end_src

   It works great, but for subtraction is has to parse the ~x~ twice. Us
   lispnicks know all about how to solve this, it comes almost naturally. That
   is a goal for *smug*.

   #+begin_src gerbil
     (def (meval)
       (def (add x) (.let* ((_ #\+) (y Nat)) (+ x y)))
       (def (sub x) (.let* ((_ #\-) (y Nat)) (- x y)))
       (.let* (x Nat) (++ (add x) (sub x))))
   #+end_src

   That only parses ~x~ once. To make it prettier, we can use ~ops~, but it does
   not, likely, effect performance.

   #+begin_src gerbil
     (def Meval (.let* ((x Nat) (f (ops [#\+ . +] [#\- . -])) (y Nat))
                  (return (f x y))))
   #+end_src

** Improving laziness, aka let's be lazy. 

   The very simple case of parsing a line. A line is any chars ending with a
   ~#\newline~, or the end of things.

   The easy way is simply to test.

   #+begin_src gerbil
     (def (.read-line)
       (.let* ((cs (many (sat (? (not (cut char=? #\newline <>))))))
               (nl (++ #\newline (if (null? cs) FAIL #!eof))))
         (list->string cs)))
   #+end_src

   While that works, it does have to run the test on every line. Now, we are
   indeterminate. So, trying as follows, we do end up with a line.

   #+begin_src gerbil
     (def (.read-line)
       (.let* ((cs (many (item)))
               (nl (++ #\newline (if (null? cs) FAIL #!eof))))
         (list->string cs)))
   #+end_src

   In fact, we end up with two lines, because ~(many (item))~ also succeeds for
   a newline, and ~++~ does both no matter what. Even better, because of how
   ~many~ is defined by returning results in decreasing order, the first line is
   the last line.

   #+begin_src gerbil
     (check ((.read-line) "asd\n123")
            =>
            `(("asd\n123" . ,(String  7 "asd\n123"))
               ("asd" . ,(String 4  "asd\n123"))))
   #+end_src

*** ~some~ and ~some1~, Part 1

    To turn that around we can define a new combinator, ~some~, and its child,
    ~some1~.

    #+begin_src gerbil :noweb-ref some
      (def (some p) (++ [] (.let* ((x p) (xs (some p))) (return [x . xs]))))
      (def (some1 p) (.let ((x p) (xs (some p))) (return [x . xs])))
    #+end_src



   #+begin_src gerbil
     (def (.read-line)
       (.let* ((cs (some (item)))
               (nl (++ #\newline (if (null? cs) FAIL #!eof))))
         (list->string cs)))
   #+end_src
   
   That improves what we see versus what we want, and the first thing returned
   is the line desired.

   #+begin_src gerbil
     (check ((.read-line) "asd\n123")
            =>
            `(("asd" . ,(String 4  "asd\n123"))
              ("asd\n123" . ,(String  7 "asd\n123"))))
   #+end_src

   While that does give us nice looking parsers that return what we want, it
   means that a parser for one line returns a result of every single character
   in the parsee.

   We can just choose the first by [[#limit_results][limiting the number of results]], but that
   still means that every time we use ~many~ or ~some~ in that manner, it will
   succeed for every single character.

   Performance, eh?

*** Lazy ~bind~

    As it is, ~bind~ calls *PV* with input, and then call *PF* on every value in
    the list returned by *PV*. This is what allows non-determinism, and the
    ability to put things shortly, but often we only want the first result, and
    only the rest if we fail somewhere else.

    We can do so! Even better, it involves being lazy. Less work, less typing,
    but at the same time non-determinism means that if we have to get out of
    bed, we will.


    #+begin_src gerbil :noweb-ref bind
       ;; (import :std/lazy)
       (def (bind p f)
         (def (sugarPF f) (lambda (v) (let (r (f v)) (if (procedure? r) r (return r)))))
         (def (callPF PF pair)
           (match pair
             ([v . inp] (((sugarPF PF) v) inp))
             (else
              (error pair " is not a pair as expected for a [v . inp] return value"))))
          (lambda (inp)
            (let lp ((r ((:P p) inp)))
              (match r 
                ([] [])                     
                ([pair . rest]
                 (if (lazy? pair)
                   (lp (append (force pair) rest))
                   (let ((PFr (callPF f pair)))
                     (if (null? PFr) (lp rest)
                         (append PFr
                                 (if (null? rest) rest
                                     (list (delay (let (vs (lp rest))
                                                    (if (void? vs) [] vs))))))))))))))
    #+end_src

    The algo is simple. We loop across the list of pairs. If the first "pair" is
    ~lazy?~, we force it, which returns a list of pairs. We append that to the
    "rest", and loop again. If it's a an actual pair, we run the *PF* and if it
    succeeds, we ~delay~ the rest. Otherwise, if it fails, we continue. 

    With that laziness, ~many~ and ~some~ become a wee bit more different then
    simply reversing the order.

    
    #+begin_src gerbil
      (def (.read-line (combine many))
        (.let* ((cs (combine (item)))
                (nl (++ #\newline (if (null? cs) FAIL #!eof))))
          (list->string cs)))
    #+end_src

    ~many~ is decreasing order, ~some~ increasing. Because of laziness, once a
    parser succeeds, they rest of the list is delayed.

    Because of how ~many~ is defined, the first result is, well, the very last
    match.

    #+begin_src gerbil
      (let (r ((.read-line many) "asd\n123"))
        (check (length r) => 2)
        (check (car r) => `("asd\n123" . ,(String 7 "asd\n123")))
        (check-predicate (cadr r) lazy?))
    #+end_src

    Yet, the delay can still be forced, like, for example, through ~bind~ aka
    ~.let*~. For example, let's say we want the first line. Here's one way.

    #+begin_src gerbil
      (let (r ((.let* ((r (.read-line many))
                       ;; the second line starts with #\1, so it we have it, this is
                       ;; the first line.
                       (_ #\1))
                      (return r)) "asd\n123"))
        (check (caar r) => "asd"))
    #+end_src

    That does use ~many~ though, so first it does everything and throws away the
    latter. Descending order.

    #+begin_src gerbil
      (let (r ((.let* ((r (.read-line many))
                       ;; the second line starts with #\1, but so does the third
                       (_ #\1))
                 (return r)) "asd\n123\n1234"))
        (check (caar r) => "asd\n123"))
    #+end_src

    Since ~some~ is the opposite, ascending, it always returns the first
    matched.


    #+begin_src gerbil
      (let (r ((.let* ((r (.read-line some))
                       ;; the second line starts with #\1, but so does the third. Some
                       ;; is the correct combinator
                       (_ #\1))
                 (return r)) "asd\n123\n1234"))
        (check (caar r) => "asd"))
    #+end_src
    
    In fact, we do not even need the test for one in this case.

    #+begin_src gerbil
      (let (r ((.let* (r (.read-line some)) (return r))
               "asd\n123\n1234"))
        (check (caar r) => "asd"))
    #+end_src

    #+begin_src gerbil
      (def counter 0)
      (def (reset-count) (set! counter 0))
      (def (count) (set! counter (1+ counter)))

      (def (many p) (.let* (_ (begin (count) (void)))
                      (++ (.let* ((x p) (xs (many p))) [x . xs]) [])))

      (def (some p) (.let* (_ (begin (count) (void)))
                      (++ [] (.let* ((x p) (xs (some p))) (return [x . xs])))))
    #+end_src



   
** Limiting the number of results
   :PROPERTIES:
   :CUSTOM_ID: limit_results
   :END:

* Primitive 
  
#+begin_src gerbil :tangle "primitive.ss" :noweb yes
  (import :std/sugar :std/srfi/1 :std/lazy
          :std/generic :std/ref)
  (export #t)

  <<return>>

  <<fail>>

  <<String-struct>>

  <<item>>

  <<p-ensure-parser>>

  <<bind>>
  
  <<.let*>>

  <<sat>>

  <<++>>

  <<c-for-rep>>

  <<sepby>>

  <<predicates>>

  (def (ensure-parser p)
    (cond
     ((procedure? p) p)
     ((char? p)
      (bind (item) (lambda (x) (if (char=? x p) (return p) (fail)))))
     ((string? p)
      (let str ((xs (string->list p)))
        (if (null? xs)
          (return p)
          (bind (item) (lambda (x) (if (char=? x (car xs)) (str (cdr xs)) (fail)))))))
     ((or (boolean? p) (null? p)) (return p))))


  ;; p ‘bind‘ f = \inp -> concat [f v inp’ | (v,inp’) <- p inp]
  ;; (def (bind p f) (lambda (inp) (append-map (cut match <> ([v . inp*] ((f v) inp*)))
  ;; ((ensure-parser p) inp))))


  (def (bind p f)
    (def (runPF PF pair) (match pair ([v . inp] ((PF v) inp))
                                (else (error pair " is not a return value pair"))))
    (lambda (inp)
      (let lp ((r ((ensure-parser p) inp)))
        (match r 
          ([] [])                     
          ([pair . rest]
           (if (lazy? pair)
             (lp (append (force pair) rest))
             (let ((PFr (runPF f pair)))
               (if (null? PFr) (lp rest)
                   (append PFr
                           (if (null? rest) rest
                               (list (delay (let (vs (lp rest))
                                              (if (void? vs) [] vs))))))))))))))
  ;;  item = \inp -> case inp of
  ;;              [] -> []
  ;;              (x:xs) -> [(x,xs)]

  (defstruct narrow (input start end))


  ;; (def (item)
  ;;   (def (str-ref thing n)
  ;;     (string-ref (let lp ((t thing))
  ;;                   (cond ((string? t) t)
  ;;                         ((pair? t) (lp (cdr t)))
  ;;                         ((narrow? t) (lp (narrow-input t)))))
  ;;                 n))
  ;;   (def (str-item thing n)
  ;;     (let ((x (str-ref thing n))
  ;;           (xs (cons (+ 1 n) thing)))
  ;;       [[x . xs]]))
  ;;   (lambda (input)
  ;;     (let (inp (if (pair? input)
  ;;                 input
  ;;                 (cons 0 input)))
  ;;       (try
  ;;        (match inp
  ;;          ([n . thing]
  ;;           (if (and (narrow? thing)
  ;;                    (or (< n (narrow-start thing))
  ;;                        (>= n (narrow-end thing))))
  ;;             []
  ;;             (str-item thing n))))
  ;;        (catch _ [])))))

  ;; (def (item)
  ;;   (lambda (input)
  ;;     (let (inp (if (pair? input)
  ;;                 input
  ;;                 (cons 0 input)))
  ;;       ;(match ([n . thing] inp 
  ;;       (try
  ;;        (let ((x (string-ref (cdr inp) (car inp)))
  ;;              (xs (cons (+ 1 (car inp)) (cdr inp))))
  ;;          [[x . xs]])
  ;;        (catch _ [])))))

  ;; emacs buffer like
  (def (point) (lambda (inp) [[(if (pair? inp) (car inp) 0) . inp]])) 

  (def (goto-char n) (lambda (inp) [(cons n (cons n (if (pair? inp) (cdr inp) inp)))]))

  (def (narrow-to-region start end)
    (lambda (inp) [(cons start (cons start (make-narrow inp start end)))]))

  (def (widen)
    (lambda (inp)
      (if (and (pair? inp) (narrow? (cdr inp)))
        (let (nimp (narrow-input (cdr inp)))
          [(cons (narrow-end (cdr inp)) nimp) ])
         [(cons #f inp)])))


  (def (run p inp (or-return #f))
    (let lp ((v ((ensure-parser p) inp)))
      (cond ((null? v) or-return)
            ((lazy? (car v))
             (let (new (force (car v)))
               (if (null? new) (lp (cdr v))
                   (lp new))))
            (#t (caar v)))))

  ;; p ++ q = \inp -> (p inp ++ q inp)

  (def (++ p q) (lambda (inp) (append ((ensure-parser p) inp) ((ensure-parser q) inp))))

  ;; first p = \inp -> case p inp of
  ;;                    [] -> []
  ;;                    (x:xs) -> [x]

  (def (.first p)
    (lambda (inp) (let (v (p inp)) (match v ([] []) ([x . xs] [x])))))


  ;; p +++ q = first (p ++ q)
  ;; We are not lazy, so have to specify.
  (def (+++ p q) (lambda (inp) (match ((ensure-parser p) inp)
                            ([] ((ensure-parser q) inp)) (xs xs))))

  (def (lazy+ p q)
    (lambda (inp) (match ((ensure-parser p) inp)
               ([] ((ensure-parser q) inp))
               (xs (append xs (list (delay ((ensure-parser q) inp))))))))

  (defsyntax (:parser stx)
    (syntax-case stx ()
      ((macro v)
       (let* ((v (syntax->datum #'v))
              (form
               (cond
                ((char? v)
                 `(bind (item) (lambda (x) (if (char=? x ,v) (return ,v) (fail)))))
                ((string? v)
                 (let (lst (string->list v))
                   `(let str ((xs ',lst))
                     (if (null? xs)
                       (return ,v)
                       (bind (item) (lambda (x)
                                      (if (char=? x (car xs)) (str (cdr xs))
                                          (fail))))))))
                (#t `(ensure-parser ,v)))))
         (with-syntax ((P (datum->syntax #'macro form)))
           #'P)) )))

  (defsyntax (.let* stx)
    (def (bind-form id value body)
      `(bind ,value (lambda (,id) ,@body)))

    (syntax-case stx ()
      ((macro bind: (values . vs) to: v body ...)
       (let* ((id (gensym)) (MV [':parser (syntax->datum #'v)])
              (MF `(lambda (,id) (let ((values . ,(syntax->datum #'vs)) ,id)
                              ,@(syntax->datum #'(body ...))))))
         (with-syntax ((bf (datum->syntax #'macro ['bind MV MF])))
           #'bf)))
      ((macro bind: id to: value body ...)
       (with-syntax ((bind-form (datum->syntax
                                    #'macro
                                  `(bind (:parser ,(syntax->datum #'value))
                                          (lambda (,(syntax->datum #'id))
                                            ,@(syntax->datum #'(body ...)))))))
         #'bind-form))
      ((macro ((id value) rest ...) body ...)
       #'(macro bind: id to: value
                (macro (rest ...) body ...)))
      ((macro (id value) body ...) #'(macro ((id value)) body ...))
      ((macro _ body ...)
       #'(let (ret (begin body ...))
           (if (procedure? ret) ret (return ret))))))
#+end_src


*** ~++~ and ~+++~ Adding simultaneous parser branches. 
    :PROPERTIES:
    :CUSTOM_ID: +++
    :END:

There are two primitives for adding parsers together to run in unison, ~++~ and
~+++~. Essentially, ~++~ is non-deterministic and ~+++~ is determined.

The easy way to explain is, of course, an example.

#+begin_src gerbil
  ((++ (item) (return [])) "asd") ;; => ((#\a 1 . "asd") (() . "asd"))
  ((+++ (item) (return [])) "asd") ;; => ((#\a 1 . "asd"))
  ((+++ (fail) (return [])) "asd") ;; => ((() . "asd"))
#+end_src

 ~++~ always runs the second parser, whereas ~+++~ only runs if the first one
fails.

~many~ takes a plus combinator as its second argument, which allows us to only
have the largest block returned.


* Simple 

** The #\. prefix
   :PROPERTIES:
   :CUSTOM_ID: Dot-prefix
   :END:

 In some cases, the natural name for a parser conflicts with a common identifier
 in Gerbil/Scheme. Rather then shadow the symbols, I've chosen to prefix certain
 parser names with a #\. character. It also helps to distinguish parser
 returning functions from other functions.


#+begin_src gerbil :tangle "simple.ss"
  (import :drewc/smug/primitive
          (for-syntax :drewc/smug/primitive)
          (only-in :std/srfi/13 string-null?)
          :std/srfi/1)
  (export #t)


  ;; sat p = item ‘bind‘ \x -> if p x then return x else fail
  (def (sat predicate (p (item))) (bind p (lambda (x) (if (predicate x) (return x) (fail)))))
  (def (satisfies predicate item: (item item))
    (bind (item) (lambda (x) (if (predicate x) (return x) (fail)))))

  (def (skip p) (+++ (bind p (lambda _ (+++ (skip p) (return #t)))) (return #f)))

  (def (liftP function . args) 
    (cut bind <> (lambda (v) (return (apply function v args)))))

  (def (.char=? c) (sat (cut char=? <> c)))
  (def (.char-ci=? c) (sat (cut char-ci=? <> c)))

  (def (ci=? thing (ret #f))
   (if (string? thing) (.string-ci=? thing ret) (.char-ci=? thing)))

  (def (peek (p (item)))
    (let (v (gensym))
      (.let* (peek (return v))
        (.or (.let* (x p) (set! peek x) (fail))
             (.let* (_ #f) (if (eq? peek v) (fail) (return peek)))))))

  (def (.begin p . ps)
    (bind p (lambda (v) (if (null? ps) (return v) (apply .begin ps)))))

  (def (.begin0 p . ps)
    (.let* ((x p) (_ (if (null? ps) (return ps) (apply .begin ps))))
      (return x)))



  (def (.or p . ps) (+++ p (if (null? ps) (fail) (apply .or ps))))
  (def (.any p . ps) (++ p (if (null? ps) (fail) (apply .any ps))))


  (def (save-excursion . ps) (if (null? ps) (fail) (peek (apply .begin ps))))

  (def (skip-chars-forward charbag (end #f))
    (def lst (if (list? charbag) charbag (string->list charbag)))
    (let sk ((ret 0))
      (.or (.let* (p (point))
             (if (and end (>= p end)) (return ret)
                (.begin (sat (cut memv <> lst)) (sk (1+ ret)))))
           (return ret))))

  (def (skip-chars-backward charbag (start #f))
    (def lst (if (list? charbag) charbag (string->list charbag)))
    (def (skb (p #f) (ret 0))
      (if (or (and p (zero? p)) (and start (<= start p))) (return ret)
          (.let* (bp (goto-char (1- p)))
            (.or (.begin (sat (cut member <> lst))
                         (skb bp (1+ ret)))
                 (.begin (item) (return ret))))))
    (bind (point) skb))

  (def (forward-line (count 1))
    (.begin (many (sat (? (not (cut char=? #\newline <>)))))
            #\newline
            (if (> count 1) (forward-line (1- count)) (point))))

  (def (beginning-of-line (count 1))
    (def (bol p)
      (if (and p (zero? p)) (return p)
          (let ((bp (1- p)))
            (.let* (c (.begin (goto-char bp) (item)))
              (if (char=? #\newline c)
                      (return p)
                      (bol bp))))))
    (.let* (_ (if (> count 1)
                (forward-line (1- count)) #f))
      (bind (point) bol)))

  (def (end-of-line (count 1))
    (def eol (.begin (skip (sat (? (not (cut char=? <> #\newline)))))
                     (point)))
    (.let* (e eol)
      (if (> count 1)
        (.begin (item) (end-of-line (1- count)))
        (return e))))

  (def (buffer-substring start end)
    (peek (.begin (goto-char start) (.make-string (- end start)))))

  (def (count-lines start end)
    (save-excursion (goto-char start)
                    (.let* (lst (.make-list (- end start) (item)))
                        (return (count (cut char=? #\newline <>) lst)))))




  ;; Some.

  (def (some p)
    (lazy+ (return []) (.let* ((x p) (xs (some p))) (cons x xs))))

  (def (some1 p) (.let* ((x p) (xs (some p))) (cons x xs)))



  ;; bracket open p close = [x | _ <- open, x <- p, _ <- close]

  (def (bracket open p close) (.let* ((_ open) (x p) (_ close)) (return x)))


  ;; many p = [x:xs | x <- p, xs <- many p] ++ [[]]

  (def (many parser (plus +++))
    (plus (.let* ((x parser) (xs (many parser plus))) (return [x . xs]))
          (return [])))

  (def (many1 p (plus +++))
    (.let* ((x p) (xs (many p plus))) [x . xs]))

  (def (at-least n parser (plus +++))
    (plus (.let* ((x parser)
                      (xs (at-least (- n 1) parser plus)))
           (return [x . xs]))
          (if (> n 0) (fail) (return []))))



  ;; sepby1:: Parser a -> Parser b -> Parser [a]
  ;; p ‘sepby1‘ sep = [x:xs | x <- p , xs <- many [y | _ <- sep , y <- p]]   

  (def (sepby1 p sep (plus +++))
    (.let* ((x p) (xs (many (.let* ((_ sep) (y p)) (return y)) plus))) 
     (return [x . xs])))


  (def (.cons p q) (.let* ((x p) (y q)) (cons x y)))

  (def (.list p . ps)
    (.let* ((x p) (xs (if (null? ps) (return ps) (apply .list ps))))
      (cons x xs)))

  (def (.make-list count (fill (item)))
    (if (zero? count) (return [])
        (.let* ((x fill) (xs (.make-list (1- count) fill))) [x . xs])))

  (def (.list->string p) ((liftP list->string) p))

  (def (.string p . ps) (.list->string (apply .list p ps)))

  (def (.make-string count (fill (item))) (.list->string (.make-list count fill)))

  (def (.string->number p) ((liftP string->number) p))



  (def (.not p)
    (.let* (?? #t)
     (.or (.let* (_ p) (set! ?? #f) (fail))
          (.let* (_ (return #!void)) (if ?? (return #t) (fail))))))

  (def (.read-line eof-fail?: (eof-fail? #f)
                   include-newline?: (nl? #t)
                   return: (ret list->string))
    (let line ((cs []))
      (.let* (c (.or (item) (return #!eof)))
        (cond ((eof-object? c) (if eof-fail? (fail) (ret (reverse! cs))))
              ((char=? #\newline c) (ret (reverse! (if nl? (cons c cs) cs))))
              (#t (line (cons c cs)))))))

  (def (.string=? str (return-parsed? #f) (char? char=?))
    (def (str= lst)
      (if (null? lst)
        (return [])
        (.let* ((c (sat (cut char? <> (car lst))))
                (cs (str= (cdr lst))))
          (if return-parsed? [c . cs] []))))
    (let (lst (string->list str))
      (.let* (v (str= lst)) (if return-parsed? (list->string v) (return str))) ))

  (def (.string-ci=? str (p? #f))
    (.string=? str p? char-ci=?))



#+end_src

* Treat it like a buffer 

Our buffer starts at 0. 

#+begin_src gerbil :tangle "buffer.ss"
 

  (def (forward-char (count 1)) (bind (point) (lambda (n) (goto-char (+ count n)))))

  (def (backward-char (count 1)) (bind (point) (lambda (n) (goto-char (- n count)))))

  (def (beginning-of-line (count 1))
    (def (beg)
    (.let* ((p (point))
                (b (if (= p 0) #f (.and (backward-char) (item)))))

      (if (or (not b)
              (char=? #\newline b))
        p
        (.and (backward-char 2) (beg)))))
    (def (giv c)
      (bind (beg) (lambda (n) (if (= c 1)
                           (return n)
                           (giv (- c 1))))))

    (giv count))

  (def (beginning-of-line (count 1))
  (def (beg)
      (.let* ((p (point))
                  (b (if (= p 0) #f (.and (backward-char) (item)))))

                 p))
  
    (def (giv c)
      (bind (beg) (lambda (n) (if (= c 1)
                           (return n)
                           (giv (- c 1))))))

    (giv count))

     
#+end_src

* /Files/ 

** ~load-primitive.ss~
#+begin_src gerbil :tangle "load-primitive.ss" :noweb yes :comment noweb
  (import :std/sugar :std/generic :std/ref :std/srfi/1 :std/lazy)
  <<return>>

  <<fail>>

  <<String-struct>>

  <<item>>

  <<p-ensure-parser>>

  <<bind>>

  <<.let*>>

  <<sat>>

  <<++>>

  <<c-for-rep>>

  <<sepby>>

  <<predicates>>

  <<some>>
#+end_src

** ~test-parser.ss~
#+begin_src gerbil :noweb yes :tangle test-parser.ss
   (import :std/test
   ; :drewc/smug
           )

   (def parser-test
     (test-suite
      "Parser"

      (test-case
       "Test primitive return/fail/item"
       <<return-test>>
       <<fail-test>>
       <<item-test>>

       )

      <<test-.list=>>

      <<test-.string=>>

     ))


  ;; <<test-c-for-rep>>
#+end_src


* footnotes	 


[fn:fokker] Fokker, Jeroen. 1995 (May). Functional parsers. Lecture notes of the
Baastad Spring school on functional programming.

[fn:1] Monadic parser combinators (pdf, ps, bibtex) Graham Hutton and
Erik Meijer. Technical Report NOTTCS-TR-96-4, Department of Computer
Science, University of Nottingham, 1996.
-- http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing

[2] http://www.willamette.edu/~fruehr/haskell/seuss.html 

