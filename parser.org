#+TITLE: Smug Parser  

#+begin_src gerbil :tangle "parser.ss"
  package: drewc

  (import :drewc/smug/primitive :drewc/smug/simple :drewc/smug/prefix)

  (export (import: :drewc/smug/primitive)
          (import: :drewc/smug/simple)
          (import: :drewc/smug/prefix))
#+end_src



* Primitive 
  
#+begin_src gerbil :tangle "primitive.ss"
  (import :std/sugar :std/srfi/1 :std/lazy)
  (export #t)

  ;; return v = \inp -> [(v,inp)]
  (def (return v) (lambda (inp) [[v . inp]]))

  ;; fail = \inp -> []
  (def (fail) (lambda _ []))

  (def (ensure-parser p)
    (cond
     ((procedure? p) p)
     ((char? p)
      (bind (item) (lambda (x) (if (char=? x p) (return p) (fail)))))
     ((string? p)
      (let str ((xs (string->list p)))
        (if (null? xs)
          (return p)
          (bind (item) (lambda (x) (if (char=? x (car xs)) (str (cdr xs)) (fail)))))))
     ((or (boolean? p) (null? p)) (return p))))


  ;; p ‘bind‘ f = \inp -> concat [f v inp’ | (v,inp’) <- p inp]
  ;; (def (bind p f) (lambda (inp) (append-map (cut match <> ([v . inp*] ((f v) inp*)))
  ;; ((ensure-parser p) inp))))


  (def (bind p f)
    (def (runPF PF pair) (match pair ([v . inp] ((PF v) inp))
                                (else (error pair " is not a return value pair"))))
    (lambda (inp)
      (let lp ((r ((ensure-parser p) inp)))
        (match r 
          ([] [])                     
          ([pair . rest]
           (if (lazy? pair)
             (lp (append (force pair) rest))
             (let ((PFr (runPF f pair)))
               (if (null? PFr) (lp rest)
                   (append PFr
                           (if (null? rest) rest
                               (list (delay (let (vs (lp rest))
                                              (if (void? vs) [] vs))))))))))))))
  ;;  item = \inp -> case inp of
  ;;              [] -> []
  ;;              (x:xs) -> [(x,xs)]

  (defstruct narrow (input start end))


  (def (item)
    (def (str-ref thing n)
      (string-ref (let lp ((t thing))
                    (cond ((string? t) t)
                          ((pair? t) (lp (cdr t)))
                          ((narrow? t) (lp (narrow-input t)))))
                  n))
    (def (str-item thing n)
      (let ((x (str-ref thing n))
            (xs (cons (+ 1 n) thing)))
        [[x . xs]]))
    (lambda (input)
      (let (inp (if (pair? input)
                  input
                  (cons 0 input)))
        (try
         (match inp
           ([n . thing]
            (if (and (narrow? thing)
                     (or (< n (narrow-start thing))
                         (> n (narrow-end thing))))
              []
              (str-item thing n))))
         (catch _ [])))))

  ;; (def (item)
  ;;   (lambda (input)
  ;;     (let (inp (if (pair? input)
  ;;                 input
  ;;                 (cons 0 input)))
  ;;       ;(match ([n . thing] inp 
  ;;       (try
  ;;        (let ((x (string-ref (cdr inp) (car inp)))
  ;;              (xs (cons (+ 1 (car inp)) (cdr inp))))
  ;;          [[x . xs]])
  ;;        (catch _ [])))))

  ;; emacs buffer like
  (def (point) (lambda (inp) [[(if (pair? inp) (car inp) 0) . inp]])) 

  (def (goto-char n) (lambda (inp) [(cons n (cons n (if (pair? inp) (cdr inp) inp)))]))

  (def (narrow-to-region start end)
    (lambda (inp) [(cons start (cons start (make-narrow inp start end)))]))

  (def (widen)
    (lambda (inp)
      (if (and (pair? inp) (narrow? (cdr inp)))
        (let (nimp (narrow-input (cdr inp)))
          [(cons (narrow-end (cdr inp)) nimp) ])
        [(cons #f inp)])))


  (def (run p inp (or-return #f))
    (let lp ((v ((ensure-parser p) inp)))
      (cond ((null? v) or-return)
            ((lazy? (car v))
             (let (new (force (car v)))
               (if (null? new) (lp (cdr v))
                   (lp new))))
            (#t (caar v)))))

  ;; p ++ q = \inp -> (p inp ++ q inp)

  (def (++ p q) (lambda (inp) (append ((ensure-parser p) inp) ((ensure-parser q) inp))))

  ;; first p = \inp -> case p inp of
  ;;                    [] -> []
  ;;                    (x:xs) -> [x]

  (def (.first p)
    (lambda (inp) (let (v (p inp)) (match v ([] []) ([x . xs] [x])))))


  ;; p +++ q = first (p ++ q)
  ;; We are not lazy, so have to specify.
  (def (+++ p q) (lambda (inp) (match ((ensure-parser p) inp)
                            ([] ((ensure-parser q) inp)) (xs xs))))

  (def (lazy+ p q)
    (lambda (inp) (match ((ensure-parser p) inp)
               ([] ((ensure-parser q) inp))
               (xs (append xs (list (delay ((ensure-parser q) inp))))))))

  (defsyntax (:parser stx)
    (syntax-case stx ()
      ((macro v)
       (let* ((v (syntax->datum #'v))
              (form
               (cond
                ((char? v)
                 `(bind (item) (lambda (x) (if (char=? x ,v) (return ,v) (fail)))))
                ((string? v)
                 (let (lst (string->list v))
                   `(let str ((xs ',lst))
                     (if (null? xs)
                       (return ,v)
                       (bind (item) (lambda (x)
                                      (if (char=? x (car xs)) (str (cdr xs))
                                          (fail))))))))
                (#t `(ensure-parser ,v)))))
         (with-syntax ((P (datum->syntax #'macro form)))
           #'P)))))

  (defsyntax (.let* stx)
    (def (bind-form id value body)
      `(bind ,value (lambda (,id) ,@body)))

    (syntax-case stx ()
      ((macro bind: (values . vs) to: v body ...)
       (let* ((id (gensym)) (MV [':parser (syntax->datum #'v)])
              (MF `(lambda (,id) (let ((values . ,(syntax->datum #'vs)) ,id)
                              ,@(syntax->datum #'(body ...))))))
         (with-syntax ((bf (datum->syntax #'macro ['bind MV MF])))
           #'bf)))
      ((macro bind: id to: value body ...)
       (with-syntax ((bind-form (datum->syntax
                                    #'macro
                                  `(bind (:parser ,(syntax->datum #'value))
                                          (lambda (,(syntax->datum #'id))
                                            ,@(syntax->datum #'(body ...)))))))
         #'bind-form))
      ((macro ((id value) rest ...) body ...)
       #'(macro bind: id to: value
                (macro (rest ...) body ...)))
      ((macro (id value) body ...) #'(macro ((id value)) body ...))
      ((macro _ body ...)
       #'(let (ret (begin body ...))
           (if (procedure? ret) ret (return ret))))))
#+end_src


*** ~++~ and ~+++~ Adding simultaneous parser branches. 
    :PROPERTIES:
    :CUSTOM_ID: +++
    :END:

There are two primitives for adding parsers together to run in unison, ~++~ and
~+++~. Essentially, ~++~ is non-deterministic and ~+++~ is determined.

The easy way to explain is, of course, an example.

#+begin_src gerbil
  ((++ (item) (return [])) "asd") ;; => ((#\a 1 . "asd") (() . "asd"))
  ((+++ (item) (return [])) "asd") ;; => ((#\a 1 . "asd"))
  ((+++ (fail) (return [])) "asd") ;; => ((() . "asd"))
#+end_src

 ~++~ always runs the second parser, whereas ~+++~ only runs if the first one
fails.

~many~ takes a plus combinator as its second argument, which allows us to only
have the largest block returned.


*  Simple 

#+begin_src gerbil :tangle "simple.ss"
  (import :drewc/smug/primitive
          (for-syntax :drewc/smug/primitive)
          (only-in :std/srfi/13 string-null?)
          :std/srfi/1)
  (export #t)

  ;; sat p = item ‘bind‘ \x -> if p x then return x else fail
  (def (sat predicate (p (item)))
      (bind p (lambda (x) (if (predicate x) (return x) (fail)))))

  (def (satisfies predicate item: (item item))
    (bind (item) (lambda (x) (if (predicate x) (return x) (fail)))))

  (def (skip p) (+++ (bind p (lambda _ (+++ (skip p) (return #t)))) (return #f)))

  (def (liftP function . args) 
    (cut bind <> (lambda (v) (return (apply function v args)))))

  (def (.char=? c) (sat (item) (cut char=? <> c)))
  (def (.char-ci=? c) (sat (item) (cut char-ci=? <> c)))

  (def (ci=? thing (ret #f))
   (if (string? thing) (.string-ci=? thing ret) (.char-ci=? thing)))

  (def (peek (p (item)))
    (let (v (gensym))
      (.let* (peek (return v))
        (.or (.let* (x p) (set! peek x) (fail))
             (.let* (_ #f) (if (eq? peek v) (fail) (return peek)))))))

  (def (.begin p . ps)
    (bind p (lambda (v) (if (null? ps) (return v) (apply .begin ps)))))

  (def (.begin0 p . ps)
    (.let* ((x p) (_ (if (null? ps) (return ps) (apply .begin ps))))
      (return x)))



  (def (.or p . ps) (+++ p (if (null? ps) (fail) (apply .or ps))))
  (def (.any p . ps) (++ p (if (null? ps) (fail) (apply .any ps))))


  (def (save-excursion . ps) (if (null? ps) (fail) (peek (apply .begin ps))))

  (def (skip-chars-forward charbag (end #f))
    (def lst (if (list? charbag) charbag (string->list charbag)))
    (let sk ((ret #f))
      (.or (.let* (p (point))
             (if (and end (>= p end)) (return ret)
                (.begin (sat (cut memv <> lst)) (sk #t))))
           (return ret))))

  (def (skip-chars-backward charbag (start #f))
    (def lst (if (list? charbag) charbag (string->list charbag)))
    (def (skb (p #f) (ret #f))
      (.or 
       (if (or (zero? p) (and start (<= start p))) (return ret)
           (.let* (bp (goto-char (1- p)))
              (.begin (sat (cut memv <> lst))
                      (skb bp #t))))
       (return ret)))
    (bind (point) skb))

  (def (forward-line (count 1))
    (.begin (many (sat (? (not (cut char=? #\newline <>)))))
            #\newline
            (if (> count 1) (forward-line (1- count)) (point))))

  (def (beginning-of-line (count 1))
    (def (bol p)
      (if (zero? p) (return p)
          (let ((bp (1- p)))
            (.let* (c (.begin (goto-char bp) (item)))
              (if (char=? #\newline c)
                      (return p)
                      (bol bp))))))
      (when (> count 1)
        (forward-line (1- count)))
    (bind (point) bol))

  (def (buffer-substring start end)
    (peek (.begin (goto-char start) (.make-string (- end start)))))

  (def (count-lines start end)
    (save-excursion (goto-char start)
                    (.let* (lst (.make-list (- end start) (item)))
                        (return (count (cut char=? #\newline <>) lst)))))




  ;; Some.

  (def (some p)
    (lazy+ (return []) (.let* ((x p) (xs (some p))) (cons x xs))))

  (def (some1 p) (.let* ((x p) (xs (some p))) (cons x xs)))



  ;; bracket open p close = [x | _ <- open, x <- p, _ <- close]

  (def (bracket open p close) (.let* ((_ open) (x p) (_ close)) (return x)))


  ;; many p = [x:xs | x <- p, xs <- many p] ++ [[]]

  (def (many parser (plus +++))
    (plus (.let* ((x parser) (xs (many parser plus))) (return [x . xs]))
          (return [])))

  (def (many1 p (plus +++))
    (.let* ((x p) (xs (many p plus))) [x . xs]))

  (def (at-least n parser (plus +++))
    (plus (.let* ((x parser)
                      (xs (at-least (- n 1) parser plus)))
           (return [x . xs]))
          (if (> n 0) (fail) (return []))))



  ;; sepby1:: Parser a -> Parser b -> Parser [a]
  ;; p ‘sepby1‘ sep = [x:xs | x <- p , xs <- many [y | _ <- sep , y <- p]]   

  (def (sepby1 p sep (plus +++))
    (.let* ((x p) (xs (many (.let* ((_ sep) (y p)) (return y)) plus))) 
     (return [x . xs])))


  (def (.cons p q) (.let* ((x p) (y q)) (cons x y)))

  (def (.list p . ps)
    (.let* ((x p) (xs (if (null? ps) (return ps) (apply .list ps))))
      (cons x xs)))

  (def (.make-list count (fill (item)))
    (if (zero? count) (return [])
        (.let* ((x fill) (xs (.make-list (1- count) fill))) [x . xs])))

  (def (.list->string p) ((liftP list->string) p))

  (def (.string p . ps) (.list->string (apply .list p ps)))

  (def (.make-string count (fill (item))) (.list->string (.make-list count fill)))

  (def (.string->number p) ((liftP string->number) p))



  (def (.not p)
    (.let* (?? #t)
     (.or (.let* (_ p) (set! ?? #f) (fail))
          (.let* (_ (return #!void)) (if ?? (return #t) (fail))))))

  (def (.read-line eof-fail?: (eof-fail? #f)
                   include-newline?: (nl? #t)
                   return: (ret list->string))
    (let line ((cs []))
      (.let* (c (.or (item) (return #!eof)))
        (cond ((eof-object? c) (if eof-fail? (fail) (ret (reverse! cs))))
              ((char=? #\newline c) (ret (reverse! (if nl? (cons c cs) cs))))
              (#t (line (cons c cs)))))))

  (def (.string=? str (return-parsed? #f) (char? char=?))
    (def (str= lst)
      (if (null? lst)
        (return [])
        (.let* ((c (sat (cut char? <> (car lst))))
                (cs (str= (cdr lst))))
         (if return-parsed? [c . cs] []))))
    (let (lst (string->list str))
      (.let* (v (str= lst)) (if return-parsed? (list->string v) (return str)))))

  (def (.string-ci=? str (p? #f))
    (.string=? str p? char-ci=?))



#+end_src

* Treat it like a buffer 

Our buffer starts at 0. 

#+begin_src gerbil :tangle "buffer.ss"
 

  (def (forward-char (count 1)) (bind (point) (lambda (n) (goto-char (+ count n)))))

  (def (backward-char (count 1)) (bind (point) (lambda (n) (goto-char (- n count)))))

  (def (beginning-of-line (count 1))
    (def (beg)
    (.let* ((p (point))
                (b (if (= p 0) #f (.and (backward-char) (item)))))

      (if (or (not b)
              (char=? #\newline b))
        p
        (.and (backward-char 2) (beg)))))
    (def (giv c)
      (bind (beg) (lambda (n) (if (= c 1)
                           (return n)
                           (giv (- c 1))))))

    (giv count))

  (def (beginning-of-line (count 1))
  (def (beg)
      (.let* ((p (point))
                  (b (if (= p 0) #f (.and (backward-char) (item)))))

                 p))
  
    (def (giv c)
      (bind (beg) (lambda (n) (if (= c 1)
                           (return n)
                           (giv (- c 1))))))

    (giv count))

     
#+end_src
